* Emacs rocks

This file contains my configurations and adaptations to
my now graphene based setup.

** Lambda

Lambda as λ

#+BEGIN_SRC emacs-lisp
  (defmacro λ (&rest body)
    `(lambda ()
       (interactive)
       ,@body))

  (global-set-key (kbd "H-l") (λ (insert "\u03bb")))
#+END_SRC


* Packages

Package management and loading of utility packages.

** Management

Cask manages the packages installed.

#+BEGIN_SRC emacs-lisp
  (require 'cask "~/.cask/cask.el")
  (cask-initialize)
#+END_SRC

*** Pallet

Using =pallet= allows to use Cask and =M-x list-packages= together --
manual operations performed using =packages.el= are reflected in the
Cask file.

#+BEGIN_SRC emacs-lisp
(require 'pallet)
(pallet-mode t)
#+END_SRC

*** Code Loading

Recompile elisp code on load or require.

Since auto-compile is installed via cask, we cannot require it before
package Management is setup.

#+BEGIN_SRC emacs-lisp
  (setq load-prefer-newer t)
  (require 'auto-compile)
  (auto-compile-on-load-mode 1)
#+END_SRC

*** Paradox

Github integration.

#+BEGIN_SRC emacs-lisp
  (require 'netrc)

  (let ((github-paradox (netrc-machine (netrc-parse "~/.netrc") "paradox")))
    (setq paradox-github-token (netrc-get github-paradox "password")))
#+END_SRC
* Home <-> Work

Some things have to be configured differently depending on where I am -- at home or at work.

#+BEGIN_SRC emacs-lisp
  (defun tom/work? ()
    "Returns `T` if the current machine is at work, `NIL` otherwise"
    (file-exists-p (expand-file-name "~/.work")))
#+END_SRC

* Emacs =custom=

#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file)
#+END_SRC

* Helper functions
** Escape HTML entities

Basics found on ergoemacs.org.

#+BEGIN_SRC emacs-lisp
  (defun tom/replace-html-chars (text)
    "Replace “<” to “&lt;” and other chars in TEXT."
    (save-restriction      
      (with-temp-buffer
        (insert text)
        (goto-char (point-min))
        (while (search-forward "&" nil t) (replace-match "&amp;" nil t))
        (goto-char (point-min))
        (while (search-forward "<" nil t) (replace-match "&lt;" nil t))
        (goto-char (point-min))
        (while (search-forward ">" nil t) (replace-match "&gt;" nil t))
        (buffer-string))))
#+END_SRC

* Graphene

Stuff looted from graphene.
** helper functions
#+BEGIN_SRC emacs-lisp
  (defun kill-default-buffer ()
    "Kill the currently active buffer -- set to C-x k so that users are not asked which buffer they want to kill."
    (interactive)
    (let (kill-buffer-query-functions) (kill-buffer)))

  (defun kill-buffer-if-file (buf)
    "Kill a buffer only if it is file-based."
    (when (buffer-file-name buf)
      (when (buffer-modified-p buf)
          (when (y-or-n-p (format "Buffer %s is modified - save it?" (buffer-name buf)))
              (save-some-buffers nil buf)))
      (set-buffer-modified-p nil)
      (kill-buffer buf)))

  (defun kill-all-buffers ()
      "Kill all file-based buffers."
      (interactive)
      (mapc (lambda (buf) (kill-buffer-if-file buf))
       (buffer-list)))

  (defun kill-buffer-and-window ()
    "Close the current window and kill the buffer it's visiting."
    (interactive)
    (progn
      (kill-buffer)
      (delete-window)))

  (defun create-new-buffer ()
    "Create a new buffer named *new*[num]."
    (interactive)
    (switch-to-buffer (generate-new-buffer-name "*new*")))

  (defun insert-semicolon-at-end-of-line ()
    "Add a closing semicolon from anywhere in the line."
    (interactive)
    (save-excursion
      (end-of-line)
      (insert ";")))

  (defun tom/comment-line-dwim (n)
    "Comment or uncomment current line and leave point after
  it. With positive prefix, apply to N lines including current
  one. With negative prefix, apply to -N lines above."
    (interactive "p")
    (comment-or-uncomment-region
     (line-beginning-position)
     (goto-char (line-end-position n)))
    (forward-line 1) (back-to-indentation))

  (defun comment-current-line-dwim ()
    "Comment or uncomment the current line."
    (interactive)
    (save-excursion
      (push-mark (beginning-of-line) t t)
      (end-of-line)
      (comment-dwim nil)))

  (defun newline-anywhere ()
    "Add a newline from anywhere in the line."
    (interactive)
    (end-of-line)
    (newline-and-indent))

  (defun increase-window-height (&optional arg)
    "Make the window taller by one line. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window arg))

  (defun decrease-window-height (&optional arg)
    "Make the window shorter by one line. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window (- 0 arg)))

  (defun decrease-window-width (&optional arg)
    "Make the window narrower by one column. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window (- 0 arg) t))

  (defun increase-window-width (&optional arg)
    "Make the window wider by one column. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window arg t))

  ;; Create a new instance of emacs
  (when window-system
    (defun new-emacs-instance ()
      (interactive)
      (let ((path-to-emacs
             (locate-file invocation-name
                          (list invocation-directory) exec-suffixes)))
        (call-process path-to-emacs nil 0 nil))))

#+END_SRC
** editing

#+BEGIN_SRC emacs-lisp
  ;;(delete-selection-mode t)
  (global-visual-line-mode t)
  (setq nlinum-format "%4d")
  (setq-default tab-width 2)
  (setq-default indent-tabs-mode nil)
  (prefer-coding-system 'utf-8)
  (set-language-environment 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)

  (show-paren-mode t)
  (setq blink-matching-paren t)
  (electric-pair-mode t)

  (require 'flycheck)
  (flycheck-mode)

  (push '("\\.json\\'" . json-mode) auto-mode-alist)

  ;; don't compile sass/scss on saving
  (setq scss-compile-at-save nil)

  ;; 2-space indent for CSS
  (setq css-indent-offset 2)

  ;; Default Ruby filetypes
  (dolist (regex
           '("\\.watchr$" "\\.arb$" "\\.rake$" "\\.gemspec$" "\\.ru$" "Rakefile$" "Gemfile$" "Capfile$" "Guardfile$" "Rakefile$" "Cheffile$" "Vagrantfile$"))
    (add-to-list 'auto-mode-alist `(,regex . ruby-mode)))

  ;; Remap newline to newline-and-indent in ruby-mode
  (add-hook 'ruby-mode-hook
            (lambda ()
              (define-key (current-local-map) [remap newline] 'reindent-then-newline-and-indent)))

#+END_SRC
** env
#+BEGIN_SRC emacs-lisp
  (require 'smex)
  (require 'flx-ido)
  (smex-initialize)

  (setq inhibit-startup-message t
        color-theme-is-global t
        uniquify-buffer-name-style 'forward
        backup-directory-alist `((".*" . ,temporary-file-directory))
        auto-save-file-name-transforms `((".*" ,temporary-file-directory t))
        ido-mode 1
        flx-ido-mode 1
        ido-enable-flex-matching t
        ido-auto-merge-work-directories-length nil
        ido-create-new-buffer 'always
        ido-use-filename-at-point 'guess
        ido-everywhere t
        ido-use-faces t)

  (fset 'yes-or-no-p 'y-or-n-p)

  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)

  (global-auto-revert-mode t)

  (ido-mode 1)
  (ido-vertical-mode 1)
  (put 'ido-complete 'disabled nil)
  (put 'ido-exit-minibuffer 'disabled nil)
  (put 'autopair-newline 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
#+END_SRC
** speedbar
#+BEGIN_SRC emacs-lisp
  (autoload 'sr-speedbar-open "sr-speedbar" "Open the in-frame speedbar" t)

  (eval-after-load 'sr-speedbar
    '(progn
       (setq speedbar-hide-button-brackets-flag t
             speedbar-show-unknown-files t
             speedbar-smart-directory-expand-flag t
             speedbar-directory-button-trim-method 'trim
             speedbar-use-images nil
             speedbar-indentation-width 2
             speedbar-use-imenu-flag t
             speedbar-file-unshown-regexp "flycheck-.*"
             sr-speedbar-width 40
             sr-speedbar-width-x 40
             sr-speedbar-auto-refresh nil
             sr-speedbar-skip-other-window-p t
             sr-speedbar-right-side nil)

       ;; Refresh the speedbar when relevant hooks are run.
       (defvar tom/speedbar-refresh-hooks)
       (defvar tom/speedbar-refresh-hooks-added nil
         "Whether hooks have been added to refresh speedbar.")

       (add-hook 'speedbar-mode-hook
                 '(lambda ()
                    (hl-line-mode 1)
                    (visual-line-mode -1)
                    (setq automatic-hscrolling nil)
                    (let ((speedbar-display-table (make-display-table)))
                      (set-display-table-slot speedbar-display-table 0 8230)
                      (setq buffer-display-table speedbar-display-table))
                    (when (not tom/speedbar-refresh-hooks-added)
                      (lambda ()
                        (mapc (lambda (hook)
                                (add-hook hook 'speedbar-refresh))
                              tom/speedbar-refresh-hooks)
                        (setq tom/speedbar-refresh-hooks-added t)))))

       ;; More familiar keymap settings.
       (add-hook 'speedbar-reconfigure-keymaps-hook
                 '(lambda ()
                    (define-key speedbar-mode-map [S-up] 'speedbar-up-directory)
                    (define-key speedbar-mode-map [right] 'speedbar-flush-expand-line)
                    (define-key speedbar-mode-map [left] 'speedbar-contract-line)))

       ;; Pin and unpin the speedbar
       (defvar tom/speedbar-pinned-directory)

       (defadvice speedbar-update-directory-contents
         (around tom/speedbar-pin-directory activate disable)
         "Pin the speedbar to the directory set in tom/speedbar-pinned-directory."
         (let ((default-directory tom/speedbar-pinned-directory))
           ad-do-it))

       (defadvice speedbar-dir-follow
         (around tom/speedbar-prevent-follow activate disable)
         "Prevent speedbar changing directory on button clicks."
         (speedbar-toggle-line-expansion))

       (defadvice speedbar-directory-buttons-follow
         (around tom/speedbar-prevent-root-follow activate disable)
         "Prevent speedbar changing root directory on button clicks.")

       (defvar tom/speedbar-pin-advice
         '((speedbar-update-directory-contents around tom/speedbar-pin-directory)
           (speedbar-dir-follow around tom/speedbar-prevent-follow)
           (speedbar-directory-buttons-follow around tom/speedbar-prevent-root-follow))
         "Advice to be enabled and disabled on tom/[un]-pin-speedbar.")

       (defun tom/speedbar-pin-advice-activate ()
         "Activate the advice applied to speedbar functions in order to pin it to a directory."
         (mapc 'ad-activate (mapcar 'car tom/speedbar-pin-advice)))

       (defun tom/pin-speedbar (directory)
         "Prevent the speedbar from changing the displayed root directory."
         (setq tom/speedbar-pinned-directory directory)
         (mapc (lambda (ls) (apply 'ad-enable-advice ls)) tom/speedbar-pin-advice)
         (tom/speedbar-pin-advice-activate))

       (defun tom/unpin-speedbar ()
         "Allow the speedbar to change the displayed root directory."
         (mapc (lambda (ls) (apply 'ad-disable-advice ls)) tom/speedbar-pin-advice)
         (tom/speedbar-pin-advice-activate))

       ;; Always use the last selected window for loading files from speedbar.
       (defvar last-selected-window
         (if (not (eq (selected-window) sr-speedbar-window))
             (selected-window)
           (other-window 1)))

       (defadvice select-window (after remember-selected-window activate)
         "Remember the last selected window."
         (unless (or (eq (selected-window) sr-speedbar-window)
                     (not (window-live-p (selected-window))))
           (setq last-selected-window (selected-window))))

       (defun sr-speedbar-before-visiting-file-hook ()
         "Function that hooks `speedbar-before-visiting-file-hook'."
         (select-window last-selected-window))

       (defun sr-speedbar-before-visiting-tag-hook ()
         "Function that hooks `speedbar-before-visiting-tag-hook'."
         (select-window last-selected-window))

       (defun sr-speedbar-visiting-file-hook ()
         "Function that hooks `speedbar-visiting-file-hook'."
         (select-window last-selected-window))

       (defun sr-speedbar-visiting-tag-hook ()
         "Function that hooks `speedbar-visiting-tag-hook'."
         (select-window last-selected-window))))

#+END_SRC
** keys
#+BEGIN_SRC emacs-lisp

(global-set-key (kbd "C-x k")
                'kill-default-buffer)
(global-set-key (kbd "C-x C-k")
                'kill-buffer-and-window)
(global-set-key (kbd "C-c n")
                'create-new-buffer)
(global-set-key (kbd "C-c N")
                'new-emacs-instance)
(global-set-key (kbd "C-;")
                'insert-semicolon-at-end-of-line)
(global-set-key (kbd "C-<return>")
                'newline-anywhere)
(global-set-key (kbd "M-C-;")
                'tom/comment-line-dwim)
(global-set-key (kbd "C->")
                'increase-window-height)
(global-set-key (kbd "C-<")
                'decrease-window-height)
(global-set-key (kbd "C-,")
                'decrease-window-width)
(global-set-key (kbd "C-.")
                'increase-window-width)
(global-set-key (kbd "M-x")
                'smex)
(global-set-key (kbd "M-X")
                'smex-major-mode-commands)
(global-set-key (kbd "C-c s")
                'sr-speedbar-select-window)

#+END_SRC
** look
#+BEGIN_SRC emacs-lisp
  ;; Work around Emacs frame sizing bug when line-spacing
  ;; is non-zero, which impacts e.g. grizzl.
  (add-hook 'minibuffer-setup-hook
            (lambda ()
              (set (make-local-variable 'line-spacing) 0)
              (local-set-key (kbd "C-n") 'ido-next-match)
              (local-set-key (kbd "C-p") 'ido-prev-match)
              (setq resize-mini-windows (featurep 'ido-vertical-mode))))
  (setq redisplay-dont-pause t)
#+END_SRC
* Global stuff
** Single frame execution
#+BEGIN_SRC emacs-lisp
  (require 'fullframe)
#+END_SRC



** Key bindings
   :PROPERTIES:
   :ID:       b186cad4-7355-4c52-a1a2-21f52a49aa5f
   :END:
 - Meta-Pause will delete the current frame
 - use f2 as tool-bar toggle (analog to f1 for menu-bar-mode)
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-<pause>") 'delete-frame)
  (global-set-key (kbd "<f1>") 'menu-bar-mode)
  (global-set-key (kbd "<f2>") 'tool-bar-mode)
  (global-set-key (kbd "<f5>") 'flyspell-mode)
  (global-set-key (kbd "<f6>") 'flyspell-prog-mode)
  (global-set-key (kbd "<f9>") 'flymake-mode)
#+END_SRC

*** Window switching/handling
#+BEGIN_SRC emacs-lisp
  (global-set-key
   (kbd "H-o")
   (defhydra hydra-window (:color amaranth)
     "window"
     ("h" windmove-left)
     ("j" windmove-down)
     ("k" windmove-up)
     ("l" windmove-right)
     ("V" (lambda ()
            (interactive)
            (split-window-right)
            (windmove-right))
      "vert")
     ("X" (lambda ()
            (interactive)
            (split-window-below)
            (windmove-down))
      "horz")
     (">" enlarge-window-horizontally)
     ("<" shrink-window-horizontally)
     ("v" shrink-window)
     ("^" enlarge-window)
     ("t" transpose-frame "'")
     ("o" delete-other-windows "one" :color blue)
     ("a" ace-window "ace")
     ("s" ace-swap-window "swap")
     ("d" ace-delete-window "del")
     ("i" ace-maximize-window "ace-one" :color blue)
     ("b" ido-switch-buffer "buf")
     ("m" headlong-bookmark-jump "bmk")
     ("q" nil "cancel")))
#+END_SRC 
*** launcher map 

Launch seldom used emacs tools via C-x l <KEY>.

Inspired/copied from endless parentheses blog

#+BEGIN_SRC emacs-lisp
  (global-set-key
   (kbd "H-L")
   (defhydra hydra-launch (:color blue :timeout 3)
     "launch"
     ("c" calc "calc")
     ("g" git-timemachine "git timemachine")
     ("d" ediff-buffers "ediff")
     ("f" find-dired "find")
     ("r" tom/projectile-ranger)
     ("G" rgrep "grep")
     ("h" man "man")
     ("p" paradox-list-packages "packages")
     ("s" tom/eshell "shell")
     ("t" proced "proced")
     ))

#+END_SRC

*** hjkl-navigation
#+BEGIN_SRC emacs-lisp
  (global-set-key
   (kbd "H-V")
   (defhydra hydra-vim-navi (:color red)
     "navigate"
     ("h" backward-char "left")
     ("j" next-line "down")
     ("k" previous-line "up")
     ("l" forward-char "right")))
#+END_SRC
*** Toggle states

#+BEGIN_SRC emacs-lisp
  (global-set-key
   (kbd "H-T")
   (defhydra hydra-toggle (:color red :timeout 3)
     "toggle"
     ("c" column-number-mode "col-nums")
     ("d" toggle-debug-on-error "debug on error")
     ("f" auto-fill-mode "auto fill")
     ("l" nlinum-mode "show line numbers")
     ("L" toggle-truncate-lines "truncate lines")
     ("g" golden-ratio-mode "1.61803")
     ("q" toggle-debug-on-quit "debug on quit")
     ("n" narrow-or-widen-dwim "narrow")
     ("b" tom/ob-confirm-toggle "babel confirmation")))

#+END_SRC

**** Narrowing

#+BEGIN_SRC emacs-lisp
  (setq narrow-to-defun-include-comments t)
  (defun narrow-or-widen-dwim (p)
    "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
  Intelligently means: region, org-src-block, org-subtree, or defun,
  whichever applies first.
  Narrowing to org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer is already
  narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing command.
           ;; Remove this first conditional if you don't want it.
           (cond ((org-in-src-block-p)
                  (org-edit-src-code)
                  (delete-other-windows))
                 ((org-at-block-p)
                  (org-narrow-to-block))
                 (t (org-narrow-to-subtree))))
          (t (narrow-to-defun))))
#+END_SRC

*** Rectangle
#+BEGIN_SRC emacs-lisp
  (defun tom/rec-ex-point-mark ()
    (interactive)
    (if rectangle-mark-mode
        (exchange-point-and-mark)
      (let ((mk (mark)))
        (rectangle-mark-mode 1)
        (goto-char mk))))

  (global-set-key
   (kbd "H-C-r")
   (defhydra hydra-rectangle (:color amaranth
                              :body-pre (rectangle-mark-mode 1)
                              :post (deactivate-mark))
     "
    ^_k_^     _d_elete    _s_tring
  _h_   _l_   _o_k        _y_ank
    ^_j_^     _n_ew-copy  _r_eset
  ^^^^        _e_xchange  _u_ndo
  ^^^^        ^ ^         _p_aste
  "
     ("h" backward-char nil)
     ("l" forward-char nil)
     ("k" previous-line nil)
     ("j" next-line nil)
     ("e" tom/rec-ex-point-mark nil)
     ("n" copy-rectangle-as-kill nil)
     ("d" delete-rectangle nil)
     ("r" (if (region-active-p)
              (deactivate-mark)
            (rectangle-mark-mode 1)) nil)
     ("y" yank-rectangle nil)
     ("u" undo nil)
     ("s" string-rectangle nil)
     ("p" kill-rectangle nil)
     ("o" nil nil)))
#+END_SRC
*** Code Folding
#+BEGIN_SRC emacs-lisp
  (vimish-fold-global-mode 1)
  (global-set-key
   (kbd "H-C-f")
   (defhydra hydra-folding (:color red)
     "
      _o_pen fold   open _a_ll folds    
      _c_lose fold  _r_efold    
      "
     ("o" vimish-fold-unfold)
     ("c" vimish-fold)
     ("a" vimish-fold-unfold-all)
     ("r" vimish-fold-refold)
     ("y" vimish-fold-avy)))
#+END_SRC
** Undo as tree

#+BEGIN_SRC emacs-lisp
  (global-undo-tree-mode)
#+END_SRC
** yasnippet Setup

   A few variables to be used in snippets.
#+BEGIN_SRC emacs-lisp
  (setq fb-author "tregner")
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (require 'yasnippet)
  (require 'warnings)
  (yas-reload-all)
  (add-to-list 'warning-suppress-types '(yasnippet backquote-change))
#+END_SRC
** Sticky window
#+BEGIN_SRC emacs-lisp
  (require 'popwin)
  (popwin-mode 1)
  ;; (pop popwin:special-display-config)
  (push '("*Flycheck error messages*" :height 0.1 :noselect t :position bottom) popwin:special-display-config)
  (push '("\*GEBEN<.*> output\*" :regexp t :position left :width 0.3 :stick t :dedicated t) popwin:special-display-config)
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (defun tom/sticky-window (name)
    "Make the window NAME sticky."
    (let ((curr-win (car (get-buffer-window-list name))))
      (set-window-buffer curr-win (get-buffer name))
      (set-window-dedicated-p curr-win t)))
#+END_SRC

*** perspectives
#+BEGIN_SRC emacs-lisp
  (global-set-key
   (kbd "H-P")
   (defhydra hydra-persp (:color red :timeout 3)
     "Perspective"
     ("d" projectile-persp-switch-project "Switch dired")
     ("s" (call-interactively 'persp-switch) "Switch/Create")
     ("m" (call-interactively 'persp-set-buffer) "Move buffer")
     ("n" persp-next "Next Perspective")
     ("p" persp-prev "Previous Perspective")
     ("i" projectile-invalidate-cache "Invalidate file cache")
     ("q" nil "Quit")))

#+END_SRC
** COMMENT Tramp Setup
#+BEGIN_SRC emacs-lisp
  (setq tramp-shell-prompt-pattern "\\(?:^\\| \\)[^]#$%>❯\n]*#?[]#$%>❯] *\\(\\[[0-9;]*[a-zA-Z] *\\)*")
#+END_SRC
* GPG setup

GPG is handled almost transparently in emacs nowadays; this setup
helps for remote sessions.

<wgreenhouse> tomterl: this assumes emacsclient/emacs --daemon are      [15:35]
    invoked from a shell that is properly setting GPG_AGENT_INFO
    already
<wgreenhouse> but according to documentation, GPG_TTY needs to be
    adjusted for each terminal
> wgreenhouse: thanks -- should be the case, I'll make a note
<taylanub> "arc4random_uniform(9000) + 1000" should give me a good      [15:36]
    4-digit random number, right ?
<wgreenhouse> tomterl: also, I really don't like it because it will     [15:38]
    screw up DISPLAY for any jobs started from the gui emacsclient
    when I am back at that machine
> wgreenhouse: Yepp - we see, when I have the time to tackle gpg,       [15:39]
    maybe I find a cleaner solution
<baboon`> how can I call several functions over a single selection
    without re-selecting between each


(defun tom/kludge-gpg-agent (frame)
  (unless (display-graphic-p)
    (setenv "DISPLAY" nil)
    (setenv "GPG_TTY" (terminal-name frame))))

(add-hook 'after-make-frame-functions 'wg/kludge-gpg-agent)

* Emacs shell

I use =vim= and =htop=, so let's add those to =eshell-visual-commands=. 

#+BEGIN_SRC emacs-lisp
  (require 'eshell)
  (require 'em-term)
  (require 'em-smart)
  (setq eshell-where-to-jump 'begin)
  (setq eshell-review-quick-commands nil)
  (setq eshell-smart-space-goes-to-end t)

  (add-to-list 'eshell-visual-commands "htop")
  (add-to-list 'eshell-visual-commands "vim")
  (add-hook 'eshell-mode-hook 'eshell-smart-initialize)
  (setq eshell-prompt-regexp "^[^#$]*[#$] ")
  (defun tom/eshell ()
    "Start or switch to an eshell specific to the current
        projectile project, or the global '*eshell*' if not in a
        project"
    (interactive)
    (if (projectile-project-p)
        (let* ((-project-root (projectile-project-root))
               (-project (projectile-default-project-name -project-root))
               (eshell-buffer-name (concat "* " -project " eshell *")))
          (eshell))
      (eshell)))
#+END_SRC

** ~eshell~ prompt
#+BEGIN_SRC emacs-lisp
  (defun eshell/ef (fname-regexp &rest dir) (ef fname-regexp default-directory))

  ;;; ---- path manipulation

  (defun pwd-repl-home (pwd)
    (interactive)
    (let* ((home (expand-file-name (getenv "HOME")))
           (home-len (length home)))
      (if (and
           (>= (length pwd) home-len)
           (equal home (substring pwd 0 home-len)))
          (concat "~" (substring pwd home-len))
        pwd)))

  (defun curr-dir-git-branch-string (pwd)
    "Returns current git branch as a string, or the empty string if
  PWD is not in a git repo (or the git command is not found)."
    (interactive)
    (when (and (eshell-search-path "git")
               (locate-dominating-file pwd ".git"))
      (let ((git-output (shell-command-to-string (concat "cd " pwd " && git branch | grep '\\*' | sed -e 's/^\\* //'"))))
        (propertize (concat "["
                (if (> (length git-output) 0)
                    (substring git-output 0 -1)
                  "(no branch)")
                "]") 'face `(:foreground "darkgreen"))
        )))

  (setq eshell-prompt-function
        (lambda ()
          (concat
           (propertize ((lambda (p-lst)
              (if (> (length p-lst) 3)
                  (concat
                   (mapconcat (lambda (elm) (if (zerop (length elm)) ""
                                              (substring elm 0 1)))
                              (butlast p-lst 3)
                              "/")
                   "/"
                   (mapconcat (lambda (elm) elm)
                              (last p-lst 3)
                              "/"))
                (mapconcat (lambda (elm) elm)
                           p-lst
                           "/")))
            (split-string (pwd-repl-home (eshell/pwd)) "/")) 'face `(:foreground "darkorange"))
           (or (curr-dir-git-branch-string (eshell/pwd)))
           (propertize "$ " 'face 'default))))

  (setq eshell-highlight-prompt nil)
#+END_SRC
* Completion

I use ~company-mode~ as completion system. For most languages I use
the newer GNU global -- with pygmentize backend -- to provide tags for
code traversal and (additional) completion.

** Configure ~company-mode~

Use ~company-mode~ globally.

I live in a case sensitive world, so don't alter the case of
completions, but provide completions without regard for the case fo
the stuff I entered.

#+BEGIN_SRC emacs-lisp
                                          ;(global-auto-complete-mode -1)
  (require 'company)
  (add-hook 'after-init-hook 'global-company-mode)
  (setq company-dabbrev-downcase nil
        company-dabbrev-ignore-case t)
#+END_SRC
*** Key bindings

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "H-SPC") 'company-complete)
#+END_SRC

** GNU global

#+BEGIN_SRC emacs-lisp
(defun gtags-root-dir ()
    "Returns GTAGS root directory or nil if doesn't exist."
    (with-temp-buffer
      (if (zerop (call-process "global" nil t nil "-pr"))
          (buffer-substring (point-min) (1- (point-max)))
        nil)))

(defun gtags-update ()
    "Make GTAGS incremental update"
    (call-process "global" nil nil nil "-u"))

(defun gtags-root-dir ()
    "Returns GTAGS root directory or nil if doesn't exist."
    (with-temp-buffer
      (if (zerop (call-process "global" nil t nil "-pr"))
          (buffer-substring (point-min) (1- (point-max)))
        nil)))

(defun gtags-update-single(filename)  
      "Update Gtags database for changes in a single file"
      (interactive)
      (start-process "update-gtags" "update-gtags" "bash" "-c" (concat "cd " (gtags-root-dir) " ; gtags --single-update " filename )))

(defun gtags-update-current-file()
      (interactive)
      (defvar filename)
      (setq filename (replace-regexp-in-string (gtags-root-dir) "." (buffer-file-name (current-buffer))))
      (gtags-update-single filename)
      (message "Gtags updated for %s" filename))

(defun gtags-update-hook()
      "Update GTAGS file incrementally upon saving a file"
      (when (and (boundp 'ggtags-mode) ggtags-mode)
        (when (gtags-root-dir)
          (gtags-update-current-file))))

(add-hook 'after-save-hook 'gtags-update-hook)
#+END_SRC
* Projects
** projectile

Use projectile automatically.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook (λ () (progn (require 'dash)(projectile-mode 1))))
#+END_SRC 

Ignore .git, and especially those in base/includes which are always to
be treated as part of the project by projectile.

Marking the root of a project are only 

- ~RoboFile.php~ for php-projects
- ~manifest.json~ for node/foxx applications (javascript)
- ~.projectile~ as manually added mark for other project types

#+BEGIN_SRC emacs-lisp
  (require 'projectile)
  (defun tom/projectile-ranger ()
    "Open `ranger' at the root of the project."
    (interactive)
    (golden-ratio-mode -1)
    (ranger (projectile-project-root)))
  (add-to-list 'projectile-globally-ignored-directories ".git")
  (add-to-list 'projectile-globally-ignored-directories "base/.git")
  (add-to-list 'projectile-globally-ignored-directories "includes/.git")
  (add-to-list 'projectile-globally-ignored-directories ".cask")
  (add-to-list 'projectile-project-root-files "RoboFile.php")
  (add-to-list 'projectile-project-root-files "manifest.json")
  (add-to-list 'projectile-project-root-files ".projectile")
  (setq projectile-project-root-files-functions '(projectile-root-top-down))
  (setq projectile-switch-project-action 'tom/projectile-ranger)
  (setq projectile-find-dir-includes-top-level t)
  (setq projectile-indexing-method 'native)
  (setq projectile-enable-caching t)

#+END_SRC
*** Perspectives
#+BEGIN_SRC emacs-lisp
(persp-mode)
(require 'persp-projectile)
#+END_SRC
*** Keys
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "H-p") 'projectile-commander)

#+END_SRC

* Appearance
** Font

#+BEGIN_SRC emacs-lisp
  (defvar tom/default-font "-CTDB-Fira Code-normal-normal-normal-*-12-*-*-*-m-0-iso10646-1"
    "The font to use under normal circumstances")

  (defvar tom/fallback-font "-Free-Symbola-normal-normal-semicondensed-*-12-*-*-*-*-0-iso10646-1"
    "Font to use, if the default font misses a glyph.")

  (setq default-frame-alist `((font . ,tom/default-font)))

  (set-fontset-font "fontset-default" '(#x10000 . #x1ffff) tom/fallback-font)

   (add-hook
    'after-make-frame-functions
    (lambda (frame)
      (set-fontset-font "fontset-default"
                        '(#x10000 . #x1ffff) tom/fallback-font frame)))
  ;;; Fira code
  ;; This works when using emacs --daemon + emacsclient
  (add-hook 'after-make-frame-functions (lambda (frame) (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")))
  ;; This works when using emacs without server/client
  (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")
  ;; I haven't found one statement that makes both of the above situations work, so I use both for now

  (defconst fira-code-font-lock-keywords-alist
    (mapcar (lambda (regex-char-pair)
              `(,(car regex-char-pair)
                (0 (prog1 ()
                     (compose-region (match-beginning 1)
                                     (match-end 1)
                                     ;; The first argument to concat is a string containing a literal tab
                                     ,(concat  "	" (list (decode-char 'ucs (cadr regex-char-pair)))))))))
            '(("\\(www\\)"                   #Xe100)
              ("[^/]\\(\\*\\*\\)[^/]"        #Xe101)
              ("\\(\\*\\*\\*\\)"             #Xe102)
              ("\\(\\*\\*/\\)"               #Xe103)
              ("\\(\\*>\\)"                  #Xe104)
              ("[^*]\\(\\*/\\)"              #Xe105)
              ("\\(\\\\\\\\\\)"              #Xe106)
              ("\\(\\\\\\\\\\\\\\)"          #Xe107)
              ("\\({-\\)"                    #Xe108)
              ("\\(\\[\\]\\)"                #Xe109)
              ("\\(::\\)"                    #Xe10a)
              ("\\(:::\\)"                   #Xe10b)
              ("[^=]\\(:=\\)"                #Xe10c)
              ("\\(!!\\)"                    #Xe10d)
              ("\\(!=\\)"                    #Xe10e)
              ("\\(!==\\)"                   #Xe10f)
              ("\\(-}\\)"                    #Xe110)
              ("\\(--\\)"                    #Xe111)
              ("\\(---\\)"                   #Xe112)
              ("\\(-->\\)"                   #Xe113)
              ("[^-]\\(->\\)"                #Xe114)
              ("\\(->>\\)"                   #Xe115)
              ("\\(-<\\)"                    #Xe116)
              ("\\(-<<\\)"                   #Xe117)
              ("\\(-~\\)"                    #Xe118)
              ("\\(#{\\)"                    #Xe119)
              ("\\(#\\[\\)"                  #Xe11a)
              ("\\(##\\)"                    #Xe11b)
              ("\\(###\\)"                   #Xe11c)
              ("\\(####\\)"                  #Xe11d)
              ("\\(#(\\)"                    #Xe11e)
              ("\\(#\\?\\)"                  #Xe11f)
              ("\\(#_\\)"                    #Xe120)
              ("\\(#_(\\)"                   #Xe121)
              ("\\(\\.-\\)"                  #Xe122)
              ("\\(\\.=\\)"                  #Xe123)
              ("\\(\\.\\.\\)"                #Xe124)
              ("\\(\\.\\.<\\)"               #Xe125)
              ("\\(\\.\\.\\.\\)"             #Xe126)
              ("\\(\\?=\\)"                  #Xe127)
              ("\\(\\?\\?\\)"                #Xe128)
              ("\\(;;\\)"                    #Xe129)
              ("\\(/\\*\\)"                  #Xe12a)
              ("\\(/\\*\\*\\)"               #Xe12b)
              ("\\(/=\\)"                    #Xe12c)
              ("\\(/==\\)"                   #Xe12d)
              ("\\(/>\\)"                    #Xe12e)
              ("\\(//\\)"                    #Xe12f)
              ("\\(///\\)"                   #Xe130)
              ("\\(&&\\)"                    #Xe131)
              ("\\(||\\)"                    #Xe132)
              ("\\(||=\\)"                   #Xe133)
              ("[^|]\\(|=\\)"                #Xe134)
              ("\\(|>\\)"                    #Xe135)
              ("\\(\\^=\\)"                  #Xe136)
              ("\\(\\$>\\)"                  #Xe137)
              ("\\(\\+\\+\\)"                #Xe138)
              ("\\(\\+\\+\\+\\)"             #Xe139)
              ("\\(\\+>\\)"                  #Xe13a)
              ("\\(=:=\\)"                   #Xe13b)
              ("[^!/]\\(==\\)[^>]"           #Xe13c)
              ("\\(===\\)"                   #Xe13d)
              ("\\(==>\\)"                   #Xe13e)
              ("[^=]\\(=>\\)"                #Xe13f)
              ("\\(=>>\\)"                   #Xe140)
              ("\\(<=\\)"                    #Xe141)
              ("\\(=<<\\)"                   #Xe142)
              ("\\(=/=\\)"                   #Xe143)
              ("\\(>-\\)"                    #Xe144)
              ("\\(>=\\)"                    #Xe145)
              ("\\(>=>\\)"                   #Xe146)
              ("[^-=]\\(>>\\)"               #Xe147)
              ("\\(>>-\\)"                   #Xe148)
              ("\\(>>=\\)"                   #Xe149)
              ("\\(>>>\\)"                   #Xe14a)
              ("\\(<\\*\\)"                  #Xe14b)
              ("\\(<\\*>\\)"                 #Xe14c)
              ("\\(<|\\)"                    #Xe14d)
              ("\\(<|>\\)"                   #Xe14e)
              ("\\(<\\$\\)"                  #Xe14f)
              ("\\(<\\$>\\)"                 #Xe150)
              ("\\(<!--\\)"                  #Xe151)
              ("\\(<-\\)"                    #Xe152)
              ("\\(<--\\)"                   #Xe153)
              ("\\(<->\\)"                   #Xe154)
              ("\\(<\\+\\)"                  #Xe155)
              ("\\(<\\+>\\)"                 #Xe156)
              ("\\(<=\\)"                    #Xe157)
              ("\\(<==\\)"                   #Xe158)
              ("\\(<=>\\)"                   #Xe159)
              ("\\(<=<\\)"                   #Xe15a)
              ("\\(<>\\)"                    #Xe15b)
              ("[^-=]\\(<<\\)"               #Xe15c)
              ("\\(<<-\\)"                   #Xe15d)
              ("\\(<<=\\)"                   #Xe15e)
              ("\\(<<<\\)"                   #Xe15f)
              ("\\(<~\\)"                    #Xe160)
              ("\\(<~~\\)"                   #Xe161)
              ("\\(</\\)"                    #Xe162)
              ("\\(</>\\)"                   #Xe163)
              ("\\(~@\\)"                    #Xe164)
              ("\\(~-\\)"                    #Xe165)
              ("\\(~=\\)"                    #Xe166)
              ("\\(~>\\)"                    #Xe167)
              ("[^<]\\(~~\\)"                #Xe168)
              ("\\(~~>\\)"                   #Xe169)
              ("\\(%%\\)"                    #Xe16a)
              ;; ("\\(x\\)"                   #Xe16b) This ended up being hard to do properly so i'm leaving it out.
              ("[^:=]\\(:\\)[^:=]"           #Xe16c)
              ("[^\\+<>]\\(\\+\\)[^\\+<>]"   #Xe16d)
              ("[^\\*/<>]\\(\\*\\)[^\\*/<>]" #Xe16f))))

  (defun add-fira-code-symbol-keywords ()
    (font-lock-add-keywords nil fira-code-font-lock-keywords-alist))

  (add-hook 'prog-mode-hook
            #'add-fira-code-symbol-keywords)
#+END_SRC

** Fontlock et.al.
   :PROPERTIES:
   :ID:       7edcd500-dcee-4484-9f44-9a65a3f29c71
   :END:

#+BEGIN_SRC emacs-lisp
  (global-font-lock-mode 1)
  (global-hl-line-mode -1)
  (line-number-mode 1)
  (column-number-mode 1)
  (setq mouse-buffer-menu-mode-mult 1)
  (setq ranger-show-literal nil)
#+END_SRC

** Scrollbar
   :PROPERTIES:
   :ID:       88e6ec5b-6aa6-4e18-b25e-7b2756d0918f
   :END:

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'scroll-bar-mode)
    (scroll-bar-mode -1))
#+END_SRC

** Menu and Toolbar

#+BEGIN_SRC emacs-lisp
  (when (fboundp tool-bar-mode)
    (tool-bar-mode -1))
  (when (fboundp menu-bar-mode)
    (menu-bar-mode -1))
#+END_SRC

** Color Theme
   :PROPERTIES:
   :ID:       eb979d64-dc35-4bdd-879c-9a73408096f2
   :END:
#+BEGIN_SRC emacs-lisp
  (setq spacemacs-theme-org-agenda-height nil)
  (setq spacemacs-theme-org-height nil)
  (load-theme 'spacemacs-dark)
  (set-face-attribute 'org-level-1 nil :height 1.0)
  (set-face-attribute 'org-level-2 nil :height 1.0)
  (set-face-attribute 'org-level-3 nil :height 1.0)
  (set-face-attribute 'org-scheduled-today nil :height 1.0)
  (set-face-attribute 'org-agenda-date-today nil :height 1.1)
  (set-face-attribute 'org-table nil :foreground "#008787")
#+END_SRC

*** Adapt company-mode
#+BEGIN_SRC emacs-lisp
  (require 'color)

  (let ((bg (face-attribute 'default :background))
        (fg (face-attribute 'default :foreground)))
    (custom-set-faces
     `(company-tooltip ((t (:inherit default :background ,(color-lighten-name bg 20)))))
     `(company-scrollbar-bg ((t (:background ,(color-lighten-name bg 12)))))
     `(company-scrollbar-fg ((t (:background ,(color-lighten-name bg 2)))))
     `(company-tooltip-selection ((t (:inherit default :foreground ,(color-lighten-name bg 12) :background ,(color-lighten-name fg 20)))))
     `(company-tooltip-common ((t (:inherit default :background ,(color-lighten-name bg 12) :foreground ,(color-lighten-name fg 20)))))))
#+END_SRC
** TreeView

*** Show nice(?) icons

#+BEGIN_SRC emacs-lisp
(setq tree-widget-image-enable 1)
#+END_SRC

** Modeline

#+BEGIN_SRC emacs-lisp
  (require 'spaceline)
  (setq powerline-default-separator 'bar)
  (require 'spaceline-config)
  (spaceline-spacemacs-theme)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (diminish 'golden-ratio-mode)
  (diminish 'undo-tree-mode)
  (diminish 'whitespace-mode)
  (diminish 'company-mode)
  (diminish 'org-src-mode)
  (diminish 'projectile-mode)
  (diminish 'repl-toggle-mode)
  (diminish 'yas-minor-mode)
  (diminish 'whitespace-mode)
#+END_SRC
** Colors on terminals

#+BEGIN_SRC emacs-lisp
(require 'color-theme-approximate)
#+END_SRC

** Highlight uncommited changes
Show uncomitted changes in the fringe.
#+BEGIN_SRC emacs-lisp
  (require 'diff-hl)
  (global-diff-hl-mode)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
#+END_SRC
** Whitespace visualization

I find it unnecessary to mark normal spaces, but to visualize tab
characters and newlines is a possible lifesaver.

#+BEGIN_SRC emacs-lisp
  (setq whitespace-display-mappings
        '(
          (newline-mark 10 [8629 10])
          (tab-mark 9 [8677 9] [92 9])
          ))

  (setq whitespace-style '(face tabs newline tab-mark newline-mark))
  (add-hook 'prog-mode-hook 'whitespace-mode)
  (add-hook 'text-mode-hook 'whitespace-mode)
#+END_SRC

	
** Hide the mode line

This is interesting for presentations (e.g.).

#+BEGIN_SRC emacs-lisp
(defvar-local hidden-mode-line-mode nil)
(defvar-local hide-mode-line nil)

(define-minor-mode hidden-mode-line-mode
  "Minor mode to hide the mode-line in the current buffer."
  :init-value nil
  :global nil
  :variable hidden-mode-line-mode
  :group 'editing-basics
  (if hidden-mode-line-mode
      (setq hide-mode-line mode-line-format
            mode-line-format nil)
    (setq mode-line-format hide-mode-line
          hide-mode-line nil))
  (force-mode-line-update)
  ;; Apparently force-mode-line-update is not always enough to
  ;; redisplay the mode-line
  (redraw-display)
  (when (and (called-interactively-p 'interactive)
             hidden-mode-line-mode)
    (run-with-idle-timer
     0 nil 'message
     (concat "Hidden Mode Line Mode enabled.  "
             "Use M-x hidden-mode-line-mode to make the mode-line appear."))))
#+END_SRC

** Minimap

This is a birds eye view of the current buffer.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "H-M") 'minimap-mode)
  
#+END_SRC

** Fringe
#+BEGIN_SRC emacs-lisp
(fringe-mode (cons nil  8))
#+END_SRC

** Frametitle
#+BEGIN_SRC emacs-lisp
  (setq frame-title-format
        '("" invocation-name ": "(:eval (if (buffer-name)
                                            (abbreviate-file-name (buffer-name))
                                          "%b"))))
#+END_SRC
** Dashboard

#+BEGIN_SRC emacs-lisp
(dashboard-setup-startup-hook)
#+END_SRC

* GNUS News and Mail

#+BEGIN_SRC emacs-lisp
  (defun tom/gnus ()
    "Setup and start GNUS"
    (interactive)
    (persp-switch "mail")
    (require 'gnus)
    (require 'gnus-util)
    (require 'smtpmail)
    (require 'nnimap)

    (if (tom/work?)
        (progn
          (setq user-mail-address "thomas.regner@fb-research.de")
          (setq user-full-name "Tom Regner")
          (setq smtpmail-smtp-server "zeta"
                send-mail-function 'smtpmail-send-it)
          (setq message-send-mail-function 'smtpmail-send-it)
          (setq smtpmail-smtp-service 25)
          (setq gnus-message-archive-method
                '(nnimap "franke_bornberg"))
          (setq gnus-message-archive-group
                "Gesendete Objekte"))
      (progn
        (setq user-mail-address "tom@goochesa.de")
        (setq user-full-name "Tom Regner")
        (setq smtpmail-smtp-server "sec.goochesa.de"
              send-mail-function 'smtpmail-send-it)
        (setq message-send-mail-function 'smtpmail-send-it)
        (setq smtpmail-smtp-service 25)))
    (setq
     starttls-use-gnutls t
     starttls-gnutls-program "gnutls-cli"
     starttls-extra-arguments "")
    (setq smtpmail-debug-info t)
    (setq smtpmail-debug-verb t)


    ;; display nice arrows in thread-view (summary buffer)
    ;; the font must have the glyphs!
    (setq-default
     gnus-summary-line-format "%U%R%z %(%&user-date;  %-15,15f %* %B%-80,80s%)\n"
     gnus-user-date-format-alist '((t . "%d.%m.%Y %H:%M"))
     gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references
     gnus-thread-sort-functions '(gnus-thread-sort-by-date)
     gnus-sum-thread-tree-false-root ""
     gnus-sum-thread-tree-indent " "
     gnus-sum-thread-tree-leaf-with-other "├► "
     gnus-sum-thread-tree-root ""
     gnus-sum-thread-tree-single-leaf "╰► "
     gnus-sum-thread-tree-vertical "│"
     )

    (setq gnus-select-method
          (if (not (tom/work?))
              '(nnimap "tomsdiner"
                       (nnimap-address "mail.tomsdiner.org")
                       (nnimap-server-port 993)
                       (nnimap-authinfo-file (expand-file-name "~/.authinfo"))
                       (nnimap-stream ssl)
                       )
            '(nnimap "franke_bornberg"
                     (nnimap-address "zeta")
                     (nnimap-server-port 143)
                     (nnimap-authinfo-file (expand-file-name "~/.authinfo"))
                     (nnimap-stream network)
                     (nnimap-inbox "INBOX")
                     (nnmail-expiry-target "nnimap+franke_bornberg:Gelöschte Objekte")
                     (nnmail-expiry-wait 'immediate)
                     )
            ))
    (if (not (tom/work?))
        (setq gnus-secondary-select-methods
              '(
                (nnimap "Goochesa"
                        (nnimap-address "sec.goochesa.de")
                        (nnimap-authinfo-file (expand-file-name "~/.authinfo"))
                        (nnimap-stream tls)
                                          ;                    (nnimap-server-port 993)
                                          ;                    (nnimap-authenticator "plain")
                        )
                )))
    ;; (setq gnus-secondary-select-methods
    ;;       '(
    ;;         ;; (nnimap "Joocom"
    ;;         ;;          (nnimap-address "127.0.0.1")
    ;;         ;;          (nnimap-server-port 20251)
    ;;         ;;          (nnimap-authinfo-file (expand-file-name "~/.authinfo"))
    ;;         ;;          (nnimap-stream ssl)
    ;;         ;;          (nnimap-authenticator "login")
    ;;         ;;          )
    ;;         (nntp "news.t-online.de")
    ;;         )
    ;;       )


    ;; lez gnus-demon check for new news and mail every 5mins, if emacs
    ;; is idle
    (defun gnus-demon-scan-mail-or-news-and-update ()
      "Scan for new mail/news and update the *Group* buffer"
      (when (gnus-alive-p)
        (save-window-excursion
          (save-excursion
            (set-buffer gnus-group-buffer)
            (gnus-group-get-new-news)))))

    (defun gnus-demon-scan-and-update ()
      (gnus-demon-scan-mail-or-news-and-update))

    ;; (gnus-demon-add-handler 'gnus-demon-scan-and-update nil 5)
    ;; (setq gnus-use-demon t)
    ;; (gnus-demon-init)

    ;; (gnus-demon-add-scanmaoupil)
    (gnus)

    (require 'ldap)
    (require 'eudc)

    ;; (setq eudc-default-return-attributes nil
    ;;       eudc-strict-return-matches nil)

    (setq ldap-ldapsearch-args (quote ("-LL" "-tt")))

    (if (tom/work?)
        (progn
          (advice-add #'eudc-ldap-simple-query-internal :filter-args
                      (lambda (args)
                        (list (append '(("objectClass" . "user")("cn" . "*")) (car args)) (car (cdr args)))))
          (let ((ldapv (netrc-machine (netrc-parse "~/.netrc") "ldapv")))
            (setq eudc-server-hotlist '(("theta" . ldap)))
            (setq ldap-host-parameters-alist
                  `(("theta"
                     base ,(netrc-get ldapv "default")
                     binddn ,(netrc-get ldapv "login")
                     passwd ,(netrc-get ldapv "password"))))
            )))
    ;; Adds some hooks

    (eval-after-load "message"
      '(define-key message-mode-map (kbd "TAB") 'eudc-expand-inline))
    (eval-after-load "sendmail"
      '(define-key mail-mode-map (kbd "TAB") 'eudc-expand-inline))
    (eval-after-load "post"
      '(define-key post-mode-map (kbd "TAB") 'eudc-expand-inline)))
#+END_SRC

** Filter atom feeds

#+BEGIN_SRC emacs-lisp
(require 'mm-url)
(defadvice mm-url-insert (after DE-convert-atom-to-rss () )
  "Converts atom to RSS by calling xsltproc."
  (when (re-search-forward "xmlns=\"http://www.w3.org/.*/Atom\""
               nil t)
    (message "Converting Atom to RSS... ")
    (goto-char (point-min))
    (call-process-region (point-min) (point-max)
             "xsltproc"
             t t nil
             (expand-file-name "~/atom2rss.xsl") "-")
    (goto-char (point-min))
    (message "Converting Atom to RSS... done")))

(ad-activate 'mm-url-insert)
#+END_SRC

** Reload gnus 

Force unload gnus (all files loaded known to me as of 2014-03-23).

#+BEGIN_SRC emacs-lisp
  (defun tom/reloadgnus ()
    "Unload all gnus files known to this function and reload gnus."
    (interactive)
    (let ((gnusfiles 
           (directory-files (expand-file-name "lisp" tom/--gnus-home) nil ".*\.el$" t)))
      (cl-loop for lib in gnusfiles do
               (ignore-errors 
                 (call-interactively
                  (unload-feature (substring-no-properties lib 0 -3)))))
      (tom/gnus)))
#+END_SRC
* mu4e
#+BEGIN_SRC emacs-lisp 
  (when (not (tom/work?))
    (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")
    (add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")
    (require 'mu4e)
    (setq mu4e-contexts
          `( ,(make-mu4e-context
               :name "goochesa"
               :match-func (lambda (_) (string-equal "goochesa" (mu4e-context-name mu4e~context-current)))
               :enter-func '()
               :leave-func (lambda () (mu4e-clear-caches))
               :vars '((mu4e-maildir . "~/Mail/Goochesa")
                       (mu4e-mu-home . "~/.mu-Goochesa")
                       (mu4e-get-mail-command . "offlineimap -a Goochesa")
                       (mu4e-drafts-folder . "/INBOX.Drafts") 
                       (mu4e-sent-folder . "/INBOX.Sent")
                       (mu4e-trash-folder . "/INBOX.Trash")
                       (user-mail-address . "tom@goochesa.de")))
             ,(make-mu4e-context
               :name "GMail"
               :match-func (lambda (_) (string-equal "GMail" (mu4e-context-name mu4e~context-current)))
               :enter-func '()
               :leave-func (lambda () (mu4e-clear-caches))
               :vars '((mu4e-maildir . "~/Mail/GMail")
                       (mu4e-mu-home . "~/.mu-GMail")
                       (mu4e-get-mail-command . "offlinegmail")
                       (mu4e-drafts-folder . "/[Google Mail].Drafts") 
                       (mu4e-sent-folder . "/[Google Mail].Sent Mail")
                       (mu4e-trash-folder . "/[Google Mail].Trash")
                       (mu4e-sent-messages-behaviour . 'delete)
                       (user-mail-address . "tomreg.tr@gmail.com")))))

    ;; something about ourselves
    (setq
     user-full-name  "Tom Regner"
     mu4e-compose-signature ""
     )

    ;; sending mail -- replace USERNAME with your gmail username
    ;; also, make sure the gnutls command line utils are installed
    ;; package 'gnutls-bin' in Debian/Ubuntu

    (require 'smtpmail)
    (setq message-send-mail-function 'smtpmail-send-it
          smtpmail-stream-type 'starttls
          smtpmail-default-smtp-server "goochesa.de"
          smtpmail-smtp-server "goochesa.de"
          smtpmail-smtp-service 587
          smtpmail-auth-credentials "~/.netrc")

    ;; don't keep message buffers around
    (setq message-kill-buffer-on-exit t))
#+END_SRC
* org-mode
** Variables
   :PROPERTIES:
   :ID:       d2eb3552-1033-4e26-ad19-f4fb5b92e551
   :END:

*** Basis / Agenda

#+BEGIN_SRC emacs-lisp
     (setq
      org-directory "~/ownCloud/org-mode"
      org-return-follows-link t
      org-src-fontify-natively t
      org-tags-exclude-from-inheritance '("PROJECT")
      org-list-allow-alphabetical nil
      org-agenda-include-inactive-timestamps t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (if (tom/work?)
      (setq org-agenda-files (list org-journal-dir)
            org-agenda-file-regexp "^\[0-9\]+")
    (setq org-agenda-files (quote ("~/ownCloud/org-mode/todos.org"
                                   "~/ownCloud/org-mode/joocom.org"))))
#+END_SRC
*** owncloud
Use ~org-cladav~ to integrate with an owncloud calendar.

x#+BEGIN_SRC emacs-lisp
  (defvar tom/--org-caldav-dir (expand-file-name "org-caldav" tom/--src-base))
  (add-to-list 'load-path tom/--org-caldav-dir)
  (require 'org-caldav)

  (defvar tom/--owncloud-base "https://muehlenweg.dyndns-home.com/owncloud/remote.php/")
  (setq
   org-caldav-url  (concat tom/--owncloud-base "caldav/calendars/tom")
   org-caldav-calendar-id "orgmode"
   org-caldav-inbox "~/ownCloud/org-mode/incoming.org"
   org-caldav-files (quote ("~/ownCloud/org-mode/todos.org"  "~/ownCloud/org-mode/joocom.org"))
   org-icalendar-timezone "Europe/Berlin")

x#+END_SRC

*** mobileorg for android

#+BEGIN_SRC emacs-lisp
  (setq
   org-mobile-directory (expand-file-name "~/ownCloud/org-mode")
   org-mobile-files (quote (org-agenda-files))
   org-mobile-inbox-for-pull (expand-file-name "~/ownCloud/org-mode/mobileorg.org"))
#+END_SRC

*** Refile

#+BEGIN_SRC emacs-lisp
(setq
    org-refile-targets (quote ((nil :maxlevel . 9)
                               (org-agenda-files :maxlevel . 9)))
    )
#+END_SRC

*** babel

The languages I like to use.

#+BEGIN_SRC emacs-lisp 
  (org-babel-do-load-languages
   'org-babel-load-languages 
   '((emacs-lisp . t)  (shell . t)
     (ditaa . t) (sass . t)
     (lisp . t) (gnuplot . t)
     (http . t)))
#+END_SRC 

The =ditaa.jar= location;

#+BEGIN_SRC emacs-lisp
  (setq org-ditaa-jar-path  (concat tom/--org-base "/contrib/scripts/ditaa.jar"))
#+END_SRC

I really like org-babel to use zsh

#+BEGIN_SRC emacs-lisp
  (setq org-babel-sh-command "zsh")
#+END_SRC

Don't confirm evaluation.
#+BEGIN_SRC emacs-lisp
  (defun tom/ob-confirm-toggle ()
    "Turn confirmation for babel code block evaluation on/off."
    (interactive)
    (setq org-confirm-babel-evaluate (not org-confirm-babel-evaluate)))
  (global-set-key (kbd "C-c c") 'tom/ob-confirm-toggle)
#+END_SRC

Use inheritance for properties, needed for e.g. my zshorg project.
#+BEGIN_SRC emacs-lisp
  (setq org-use-property-inheritance t)
#+END_SRC
** Tangle hook

Remove code references in code prior to tangling; that way I can use
them anywhere in the code and get nice links/references in the weaved
document, but don't have to hide them in code comments. 

I always use the form ~(ref:label)~ for code references.

#+BEGIN_SRC emacs-lisp
  (defun tr/remove-code-labels ()
    "remove (ref:.*) from all lines"
    (goto-char (point-min))
    (let* (
           (lbl-re "[ \t]*(ref:[a-zA-Z0-9_-]*)"
                   ))
      (while (re-search-forward lbl-re nil t)
        (replace-match "")
        )))
  
  ;(add-hook 'org-babel-tangle-body-hook
  ;          (λ () (tr/remove-code-labels)))
  
#+END_SRC 

** agenda views
   :PROPERTIES:
   :ID:       ebf5af82-57f0-490c-9496-f118640b25e5
   :END:

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-custom-commands
  '(

  ("P" "Projects"
  ((tags "PROJECT")))

  ("H" "Office and Home Lists"
       ((agenda)
            (tags-todo "OFFICE")
            (tags-todo "HOME")
            (tags-todo "COMPUTER")
            (tags-todo "DVD")
            (tags-todo "READING")))
  ("O" "Office and Home Lists"
       ((agenda)
            (tags-todo "OFFICE")
            ))

  ("D" "Daily Action List"
       (
            (agenda "" ((org-agenda-ndays 1)
                        (org-agenda-sorting-strategy
                         (quote ((agenda time-up priority-down tag-up)
       )))
                        (org-deadline-warning-days 0)
                        ))))
  )
  )
#+END_SRC

** org2blog

Currently not functioning correctly.

#+BEGIN_SRC emacs-lisp
  (require 'netrc)
  (setq blog (netrc-machine (netrc-parse "~/.netrc") "joocomblog" t))
  (setq org2blog/wp-blog-alist '(("joocom"
                                  :url "http://www.joocom.de/blog/xmlrpc.php"
                                  :username (netrc-get blog "login")
                                  :password (netrc-get blog "password")
                                          ; :default-title "Toms Discovery: "
                                          ; :default-categories ("Geeks!", "Software Entwicklung", "Systemadministration")
                                          ; :tags-as-categories nil
                                  )
                                 ))

#+END_SRC 

** minted

Settings to set code in latex documents with syntax highlighting.

#+BEGIN_SRC emacs-lisp
  (setq org-latex-listings 'minted)
  (setq org-latex-packages-alist '(("" "minted")))
  (setq org-latex-custom-lang-environments
        '(
          (emacs-lisp "common-lispcode")
          (lisp "common-lispcode")
          (R "rcode")))
  (setq org-latex-minted-options
        '(("frame" "lines")
          ("fontsize" "\\scriptsize")
          ))
  (setq org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode  -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode  -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode  -output-directory %o %f"))
#+END_SRC

** =org-macs= 
Why the hell do I do this?
#+BEGIN_SRC emacs-lisp
(require 'org-macs)
#+END_SRC
** Journal
#+BEGIN_SRC emacs-lisp
  (if (not (tom/work?))
      (setq org-journal-dir (expand-file-name "~/ownCloud/org-mode/journal/"))
    (setq org-journal-dir (expand-file-name "~/Documents/journal/")))
#+END_SRC
** tomsdiner.org
#+BEGIN_SRC emacs-lisp
  ;;  (require 'org-publish)
  (if (not (tom/work?))
      (let* ((tdo (netrc-machine (netrc-parse "~/.netrc") "tdo"))
             (remote-dir (concat (netrc-get tdo "login") (netrc-get tdo "account")))
             (remote-static-dir (concat remote-dir "static/")))
        (setq org-publish-project-alist
              `(("tdo"
                 :components ("tdo-content" "tdo-static"))
                ("tdo-content"
                 :base-directory "~/Projekte/tomsdiner.org/"
                 :base-extension "org"
                 :publishing-directory ,remote-dir
                 :recursive t
                 :publishing-function org-html-publish-to-html
                 :export-with-tags nil
                 :headline-levels 4             ; Just the default for this project.
                 :with-toc nil
                 :section-numbers nil
                 :with-sub-superscript nil
                 :with-todo-keywords nil
                 :with-author nil
                 :with-creator nil
                 :html-preamble "<div class=\"navi\">
                             <b>
                               <a href=\"/index.html\" class=\"home\">Me+Myself+I</a>
                             </b>
                             &nbsp;&mdash;&nbsp;
                             <a href=\"/myself/index.html\">myself</a>
                             &nbsp;&mdash;&nbsp;
                             <a href=\"http://github.com/tomterl\">projects</a>
                           </div>
                           <hr/>"
                 :html-postamble "<hr/><div class=\"footer\">
                              <a href=\"/imprint.html\">imprint</a>
                            </div>"
                 :html-head "<link rel=\"stylesheet\"
                           href=\"/static/css/style.css\" type=\"text/css\"/>"
                 :html-head-include-default-style nil
                 :with-timestamp t
                 :exclude-tags ("noexport" "todo")
                 :auto-preamble t)
                ("tdo-static"
                 :base-directory "~/Projekte/tomsdiner.org/static/"
                 :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf\\|otf"
                 :publishing-directory ,remote-static-dir
                 :recursive t
                 :publishing-function org-publish-attachment)))))
#+END_SRC
** Presentations
#+BEGIN_SRC emacs-lisp
(setq org-reveal-root "file:///home/tregner/opt/reveal.js")
#+END_SRC
* Chat and instant messaging 

I used to use =erc=, but I'm giving circe a try -- it just turned 1.5
today :-). 

** =circe= Options

Reduce the 'leaving/enter' messages.

#+BEGIN_SRC emacs-lisp
  (enable-circe-color-nicks)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq circe-reduce-lurker-spam t)
#+END_SRC

A more fluid display setup 
#+BEGIN_SRC emacs-lisp
  (setq
   lui-time-stamp-position 'right-margin
   lui-fill-type nil)

  (add-hook 'lui-mode-hook 'tom/lui-setup)
  (defun tom/lui-setup ()
    (setq
     fringes-outside-margins t
     right-margin-width 7
     word-wrap t
     wrap-prefix "    "))
#+END_SRC
Enable logging for channels, this is nice for bitlbee conversations.

The manual must be out of date, this doesn't load.

#+BEGIN_SRC emacs-lisp
;  (require 'circe)
;  (require 'lui-autoloads)
;  (enable-lui-logging)
#+END_SRC

** Color the nicknames.


** Don't show the names list at join
#+BEGIN_SRC emacs-lisp
;(circe-set-display-handler "353" (lambda (&rest args) nil))
#+END_SRC
** Spellchecking

#+BEGIN_SRC emacs-lisp
  (setq lui-flyspell-p t
        lui-flyspell-alist '((".*" "american")))
#+END_SRC

** Server 
#+BEGIN_SRC emacs-lisp
  (defun tom/set-circe-options ()
    "Set the networks options dynamically just before connection,
      after loading the passwords"
    (if (tom/work?)
        (let ((--bitlbee (netrc-machine (netrc-parse "~/.netrc") "bitlbee" t)))
          (setq circe-network-options
                (list
                 (list "Bitlbee"
                       :nick (netrc-get --bitlbee "login")
                       :nickserv-password (netrc-get --bitlbee "password")))))
      (let ((--freenode (netrc-machine (netrc-parse "~/.netrc") "freenode" t))
            (--bitlbee  (netrc-machine (netrc-parse "~/.netrc") "bitlbee" t)))
        (setq circe-network-options
              (list
               (list "ZNC"
                     :user (netrc-get --freenode "login")
                     :host "muehlenweg.dyndns-home.com"
                     :pass (netrc-get --freenode "password")
                     :port 6667
                     )
               (list "Bitlbee"
                     :nick (netrc-get --bitlbee "login")
                     :nickserv-password (netrc-get --bitlbee "password")))))))
#+END_SRC
   
** Smart connect

Straight out of the =circe= wiki

#+BEGIN_SRC emacs-lisp
  (defun circe-network-connected-p (network)
    "Return non-nil if there's any Circe server-buffer whose
  `circe-server-netwok' is NETWORK."
    (catch 'return
      (dolist (buffer (circe-server-buffers))
        (with-current-buffer buffer
          (if (string= network circe-server-network)
              (throw 'return t))))))

  (defun circe-maybe-connect (network)
    "Connect to NETWORK, but ask user for confirmation if it's
  already been connected to."
    (interactive "sNetwork: ")
    (if (or (not (circe-network-connected-p network))
            (y-or-n-p (format "Already connected to %s, reconnect?" network)))
        (circe network)))
  (defun irc ()
    "Connect to all configured IRC servers"
    (interactive)
    (persp-switch "chat")
    (tom/set-circe-options)
    (if (not (tom/work?))
        (circe-maybe-connect "ZNC"))
    (circe-maybe-connect "Bitlbee"))
#+END_SRC

** Desktop notifications

Ruben Maher expanded my idea to a full-fledged solution available on
github: [[https://github.com/eqyiel/circe-notifications]].

Notify me when tracked buffers have activity -- but not more than one
notification in a given time intervall.

#+BEGIN_SRC emacs-lisp
  (autoload 'enable-circe-notifications "circe-notifications" nil t)

  (eval-after-load "circe-notifications"
    '(setq circe-notifications-watch-strings
           '("Martin" "mregner" "Sascha" "saschab" "bgeisler" "sabrina" "olivers")
           circe-notifications-timeout 3000))

  (add-hook 'circe-server-connected-hook 'enable-circe-notifications)
#+END_SRC
** Away/Return
#+BEGIN_SRC emacs-lisp
  (defun tom/chataway ()
    "Set status to 'away NA' and reduce priority to 0"
(interactive)
    (with-current-buffer "&bitlbee"
      (goto-char (point-max))
      (insert "acc jabber set priority 0")
      (call-interactively 'lui-send-input)
      (insert "/away NA")
      (call-interactively 'lui-send-input)
      (message "You are away... (&bitlbee)")))
  (global-set-key (kbd "H-C-a") (λ (tom/chataway)))

  (defun tom/chatreturn ()
    "Set status to 'away NA' and reduce priority to 0"
(interactive)
    (with-current-buffer "&bitlbee"
      (goto-char (point-max))
      (insert "acc jabber set priority 10")
      (call-interactively 'lui-send-input)
      (insert "/away")
      (call-interactively 'lui-send-input)
      (message "Welcome back... (&bitlbee)")))
  (global-set-key (kbd "H-C-r") (λ (tom/chatreturn)))
#+END_SRC
* Behaviour
** Generic Version Control interface
#+BEGIN_SRC emacs-lisp
(fullframe vc-annotate quit-window nil)
#+END_SRC
** rgrep
#+BEGIN_SRC emacs-lisp
(fullframe/split-screen rgrep quit-window "*grep*" 'horizontal 't)
#+END_SRC
** File encoding

Everything should be in utf-8. 

#+BEGIN_SRC emacs-lisp
  (prefer-coding-system 'utf-8)
#+END_SRC

** =ibuffer= as buffer screen
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC
** vi-like paren-jump
   :PROPERTIES:
   :ID:       1fada2eb-6533-42da-9c90-63042b99cbc1
   :END:
Use % to jump to corresponding parens

#+BEGIN_SRC emacs-lisp
  (defun goto-match-paren (arg)
    "Go to the matching parenthesis if on parenthesis, otherwise insert
  the character typed."
    (interactive "p")
    (cond ((looking-at "\\s\(") (forward-list 1) (backward-char 1))
      ((looking-at "\\s\)") (forward-char 1) (backward-list 1))
      (t                    (self-insert-command (or arg 1))) ))
  (global-set-key "%" `goto-match-paren)
#+END_SRC

** indentation

Indent using spaces, 2 spaces for each indentation step.

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2)
(setq-default indent-tabs-mode nil)
(setq-default c-basic-offset 2)
#+END_SRC

Indent autimatically as aggressive as possible:

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'aggressive-indent-mode)
#+END_SRC
** Flyspell: Change dictionary; key-bindings

#+BEGIN_SRC emacs-lisp
  (defun fd-switch-dictionary()
    (interactive)
    (let* ((dic ispell-current-dictionary)
           (change (if (string= dic "deutsch") "english" "deutsch")))
      (ispell-change-dictionary change)
      (message "Dictionary switched from %s to %s" dic change)
      ))
  
  (global-set-key (kbd "<f8>")   'fd-switch-dictionary)
#+END_SRC 

#+BEGIN_SRC emacs-lisp
  (require 'flyspell-correct-ido)
  (define-key flyspell-mode-map (kbd "H-;") 'flyspell-correct-previous-word-generic)
#+END_SRC
** Multiple Cursors

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
  (global-set-key (kbd "C-c M-.") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-c M-,") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c M-a") 'mc/mark-all-like-this)
#+END_SRC

*** Multicursor mark region

After using expand-region the point remains at the start of the
region. Switch point and mark and call multi-cursor.

#+BEGIN_SRC emacs-lisp
  (defun tom/mcdwim ()
    ""
    (interactive)
    (progn
      (exchange-point-and-mark)
      (mc/mark-all-dwim nil)))
  (global-set-key (kbd "\C-c r") 'tom/mcdwim)
#+END_SRC

** Expand region

Context/Language aware region expansion/contraction.

#+BEGIN_SRC emacs-lisp
  (require 'expand-region)
  (global-set-key (kbd "C-=") 'er/expand-region)
#+END_SRC

** REPL toggle

#+BEGIN_SRC emacs-lisp

  (require 'repl-toggle)
  (setq rtog/mode-repl-alist '(
                               (php-mode . tom/psysh) 
                               (emacs-lisp-mode . ielm)
                               (elixir-mode . elixir-mode-iex)
                               (ruby-mode . inf-ruby)
                               (js2-mode . nodejs-repl)
(js3-mode . nodejs-repl)))
  (setq rtog/fullscreen t)
  (setq rtog/split-screen t)
#+END_SRC

** Opening URLs

Send them to firefox, with keysnail much better then anything else.

#+BEGIN_SRC emacs-lisp
  (setq
   browse-url-browser-function (quote browse-url-firefox))
#+END_SRC

** Speedbar
*** Automatic update

I like speedbar to update automaticly, to always reflect the current state of affairs.

#+BEGIN_SRC emacs-lisp
  (require 'sr-speedbar)
  (sr-speedbar-refresh-turn-on)
#+END_SRC

*** Toggle key

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "H-N") 'sr-speedbar-toggle)
#+END_SRC

** Scrolling

Scroll as much as other programs do, one line at a time and with
enough context around point visible.

#+BEGIN_SRC emacs-lisp
(require 'smooth-scrolling)
(smooth-scrolling-mode)
#+END_SRC

** Insert current date

Use the 'calendar' to get and format the date.

#+BEGIN_SRC emacs-lisp
  (require 'calendar)

  (defun tom/insert-current-date (&optional omit-day-of-week-p)
    "Insert today's date using the current locale.
      With a prefix argument, the date is inserted without the day of
      the week."
    (interactive "P*")
    (insert (calendar-date-string (calendar-current-date) nil
                                  omit-day-of-week-p)))
  (global-set-key (kbd "\C-c d") 'tom/insert-current-date)
#+END_SRC
** Window movement

See hydra above for movement!

*** Window Layouts / Rotation

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "H-r") 'rotate-window)
  (global-set-key (kbd "H-C-l") 'rotate-layout)
#+END_SRC

** EDiff

Sensible setup found at 'or emacs('.

#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-diff-options "-w")
  (defun tom/ediff-hook ()
    (ediff-setup-keymap)
    (define-key ediff-mode-map "j" 'ediff-next-difference)
    (define-key ediff-mode-map "k" 'ediff-previous-difference))

  (add-hook 'ediff-mode-hook 'tom/ediff-hook)

#+END_SRC
** dired
#+BEGIN_SRC emacs-lisp
  (require 'dired-x)
  (put 'dired-find-alternate-file 'disabled nil)
  (setq dired-omit-files "^\\..*$")
#+END_SRC
** highlights
#+BEGIN_SRC emacs-lisp
  (require 'volatile-highlights)
  (vhl/define-extension 'ut 'undo-tree-redo 'undo-tree-undo)
  (vhl/load-extension 'ut)
  (add-hook 'prog-mode-hook (λ () (volatile-highlights-mode 1)))
#+END_SRC
** Edit as root
#+BEGIN_SRC emacs-lisp
  (defun tom/sudo ()
    "Use TRAMP to `sudo' the current buffer"
    (interactive)
    (when buffer-file-name
      (find-alternate-file
       (concat "/sudo:root@localhost:"
               buffer-file-name))))
#+END_SRC
** Case handling
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "H-c") 'string-inflection-all-cycle)
#+END_SRC
** Lookup documentation 
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "H-z") 'zeal-at-point)
#+END_SRC
** Occur ~word-at-point~
#+BEGIN_SRC emacs-lisp
  (defun tom/occur-tap ()
    "Call occur with word-at-point"
    (interactive)
    (occur (word-at-point))
    )
  (defun tom/kill-occur-window ()
    "Kill the *Occur* buffer/window"
    (interactive)
    (let ((buffer (get-buffer "*Occur*")))
      (when buffer
        (with-current-buffer-window
         buffer
         nil
         nil
         (kill-buffer-and-window)))))
  (global-set-key (kbd "H-f") 'tom/occur-tap)
  (global-set-key (kbd "H-F") 'tom/kill-occur-window)
#+END_SRC
** View buffers
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "H-v") 'view-mode)
#+END_SRC
** Multiple Major Modes
#+BEGIN_SRC emacs-lisp
  (require 'mmm-mode)
  (mmm-add-classes
   '((embedded-aql
      :submode aql-mode
      :front "^\\(.*aql`\\)"
      :front-offset (end-of-line 1)
      :back "`"
      :insert ((?a embaql nil
                   @ "var query = aql`" @ "\n" _ "\n" @ "`;" @)))
     (embedded-sql
      :submode sql-mode
      :front "^\\(.*$\\(source\\|sql\\) = [\"']\\)"
      :back "[\"'];"
      :insert ((?s embsql "Varname (source|sql)? "
                   @ "$" str " = \"\n" @ _ @ "\n\";" @)
               (?o embsqlsource ?s . "source")
               (?q embsqlsql ?s . "sql"))
      :front-offset (end-of-line 1)
      :save-matches t)
     (embedded-js
      :submode js2-mode
      :front "^        body: >"
      :front-offset '(end-of-line 11)
      :back  "\\(^      - name: \\)\\|\\(^    types:\\)")))
  (setq mmm-global-mode 'maybe)
  (mmm-add-mode-ext-class 'js2-mode nil 'embedded-aql)
  (mmm-add-mode-ext-class 'php-mode nil 'embedded-sql)
  (mmm-add-mode-ext-class 'yaml-mode nil 'embedded-js)
#+END_SRC
*** Edit in different mode in narrowed buffer
#+BEGIN_SRC emacs-lisp
  (defmacro tom/edit-narrowed (mode mark begin end &optional fun)
    "If point is inside a `begin...end' block, create a narrowed,
    indirect buffer in `mode' to edit the contents between those
    markers. 

    Press `C-c C-c' inside the buffer to close the window
    and kill the indirect buffer.

    `mark' is used in the construction of the name for the indirect buffer.

    If `fun' is given, it is called with the narrowed buffer as current buffer."
    `(let ((bufname (concat " *"(buffer-name) "." ,mark  "*")))
       (with-current-buffer (if (get-buffer bufname) bufname (clone-indirect-buffer bufname nil))
         (unless (buffer-narrowed-p)
           (let ((max (- (search-forward-regexp ,end) (- (match-end 0) (match-beginning 0))))
                 (min (+ (search-backward-regexp ,begin) (- (match-end 0) (match-beginning 0)))))
             (narrow-to-region min max)))
         (funcall ,mode)
         (aggressive-indent-mode nil)
         (font-lock-fontify-block)
         (if (functionp ,fun) (funcall ,fun))
         (local-set-key (kbd "C-c C-c") #'(lambda ()
                                            (interactive)
                                            (progn
                                              (kill-this-buffer)
                                              (delete-window (selected-window))
                                              (mmm-parse-buffer))))
         (pop-to-buffer bufname))))

#+END_SRC
** pomodoro
Configure the pomidor package.
#+BEGIN_SRC emacs-lisp
  (setq alert-default-style 'libnotify)
  (defun tom/pomidor ()
    "Ensure pomidor is started in persp main"
    (interactive)
    (let ((buff (current-buffer))
          (pers (persp-name persp-curr)))
      (pomidor)
      (persp-switch "main")
      (let ((pom-buff (get-buffer "*pomidor*")))
        (persp-set-buffer pom-buff)
        (switch-to-buffer pom-buff)
        (local-set-key (kbd "q") `(lambda ()
                                    ""
                                    (interactive)
                                    (progn
                                      (persp-switch ,pers)
                                      (switch-to-buffer ,buff))))
        (local-set-key (kbd "Q") `(lambda ()
                                    ""
                                    (interactive)
                                    (progn
                                      (persp-remove-buffer ,pom-buff)
                                      (persp-switch ,pers)
                                      (switch-to-buffer ,buff)
                                      (kill-buffer ,pom-buff)))))))
  (global-set-key (kbd "H-t") 'tom/pomidor)
#+END_SRC
** Help
#+BEGIN_SRC emacs-lisp
  (global-set-key
   (kbd "H-h")
   (defhydra hydra-help (:color blue :timeout 3)
     "launch"
     ("h" helpful-at-point "Loopup Function/Macro")
     ("v" helpful-variable "Lookup Variable")
     ("g" helpful-update "Refresh Helpful Buffer")
     ))
#+END_SRC
* Languages
** Elixir

Automatically add =end= when typing =do=.

#+BEGIN_SRC emacs-lisp
  (require 'elixir-mode)
  (add-to-list
   'elixir-mode-hook
   (defun auto-activate-ruby-end-mode-for-elixir-mode ()
     (set (make-variable-buffer-local 'ruby-end-expand-keywords-before-re)
          "\\(?:^\\|\\s-+\\)\\(?:do\\)")
     (set (make-variable-buffer-local 'ruby-end-check-statement-modifiers) nil)
     (ruby-end-mode +1)))
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (defun tom/elixir-mode-hook ()
    ""
    (progn 
      (require 'alchemist)
      (set (make-local-variable 'company-backends)
           '((Alchemist-company :with company-yasnippet company-dabbrev-code)))
      (flycheck-mode 1)
      (yas-minor-mode 1)))
  (add-hook 'elixir-mode-hook 'tom/elixir-mode-hook)

#+END_SRC
*** Imenu 

Add speedbar support for elixir files.

#+BEGIN_SRC emacs-lisp
  (require 'speedbar)
  (speedbar-add-supported-extension ".ex")
  (speedbar-add-supported-extension ".exs")
#+END_SRC

** Rust

#+BEGIN_SRC emacs-lisp
  (setenv "RUST_SRC_PATH" "/home/tom/Projects/rust/src")
  (defun tom/rust-mode-hook ()
    ""
    (progn
      (require 'company-racer)
      (setq tab-width 4
            c-basic-offset 4
            indent-tabs-mode nil
            )
      (set (make-local-variable 'company-backends)
           '((company-racer :with :sorted company-yasnippet)))
      (cargo-minor-mode 1)))
  (add-hook 'rust-mode-hook 'tom/rust-mode-hook)
#+END_SRC
** Shell
#+BEGIN_SRC emacs-lisp
  (defun tom/sh-mode-hook ()
    ""
    (flycheck-mode 1))
  (add-hook 'sh-mode-hook 'tom/sh-mode-hook)
#+END_SRC
** PHP
*** Use php-mode, not web-mode for PHP-code

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.php$" . php-mode))
  (add-to-list 'auto-mode-alist '("\\.inc$" . php-mode))
#+END_SRC

*** smarty 

Use ~web-mode~ for smarty templates.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.tpl$" . web-mode))
#+END_SRC
*** Indentation and behaviour

Indent with 4 spaces. Use flycheck, but dont't use the "controversial" and "cleancode" rulesets of phpmd. Use ~ac-php~ as company backend. Recreate the tags when a file is saved.

#+BEGIN_SRC emacs-lisp
  (defun tom/php-tags-update ()
    ""
    (if (and (boundp 'call-php-tags-func) call-php-tags-func)
        (ac-php-remake-tags))
    )
  (add-hook 'after-save-hook 'tom/php-tags-update)
  (defun tom/php-mode-hook ()
    ""
    (progn 
      (require 'company-php)
      (setq tab-width 4
            c-basic-offset 4
            indent-tabs-mode nil
            php-template-compatibility nil
            flycheck-phpmd-rulesets '("codesize" "design" "naming" "unusedcode")
            php-mode-coding-style (quote wordpress)
            php-lineup-cascaded-calls t)
      (set (make-local-variable 'company-backends)
           '((company-ac-php-backend :with :sorted company-yasnippet)))
      (set (make-local-variable 'call-php-tags-func) t)
      (ggtags-mode -1)
      (flycheck-mode 1)
      (repl-toggle-mode 1)
      (yas-minor-mode 1)
      (company-mode 1)
      (local-set-key (kbd "M-.") 'ac-php-find-symbol-at-point)
      (local-set-key (kbd "M-,") 'ac-php-location-stack-back)
      (local-set-key (kbd "C-c a") 'tom/edit-sql)))

  (add-hook 'php-mode-hook 'tom/php-mode-hook)
#+END_SRC
*** Remote debugging

Geben has a new maintainer, it has some issues, but is overall working sufficiently well.

 #+BEGIN_SRC emacs-lisp
   (setq geben-dbgp-default-port 9000)
   (setq geben-display-window-function 'switch-to-buffer)
   (setq geben-full-frame-mode t)
 #+END_SRC

Reroute remote paths to my dev-server and the vagrant user via tramp.

#+BEGIN_SRC emacs-lisp
  (defun tom/geben-tramp-spec (remote-path)
    ""
    (print "/sshx:vagrant@192.168.254.254:"))
  (fset 'geben-get-tramp-spec-for 'tom/geben-tramp-spec)
#+END_SRC

Make the context window sticky
#+BEGIN_SRC emacs-lisp
  (setq tom/geben-context-buffer-name "*GEBEN<127.0.0.1:9000> context*")
  (defadvice geben-display-context (after sticky-geben-context-window activate)
    (tom/sticky-window tom/geben-context-buffer-name))
  (defadvice geben-display-context (before sticky-geben-context-window activate)
    (unless (buffer-live-p (get-buffer tom/geben-context-buffer-name))
      (split-window-right)))
#+END_SRC
*** Check/correct @param tags
Check the doc comment of the current function for @param tags, create them if not present. This is used in the function-snippet, but needs an overhaul...

#+BEGIN_SRC emacs-lisp
  (defun tom/php-check-params ()
    ""
    (interactive)
    (save-excursion
      (narrow-to-defun t)
      (goto-char (point-min))
      (search-forward-regexp "function[^(]*(\\(.*\\))\\(?:;\\| {\\)")
      (let ((params (split-string (match-string-no-properties 1) ", " t " ")))
        (dolist (param params)
          (let* ((parts (split-string param " "))
                 (pname (if (cadr parts) (cadr parts) (car parts)))
                 (param-parts (split-string pname "=" t " "))
                 (type (if (cadr parts) (car parts) nil))
                 (name (car param-parts))
                 (default (cadr param-parts))
                 (typemsg (if type type (if (numberp default) "int" "mixed")))
                 (defaultmsg (if default
                                 (concat "optional, default '"
                                         (if (numberp default)
                                             (number-to-string default)
                                           default)
                                         "'")
                               "")))
            (save-excursion
              (unless (search-backward-regexp (concat "@param .*" name) nil t)
                (let* ((text1 (s-trim (s-join " " (list typemsg name defaultmsg))))
                       (param-text (s-join " " (list "\n* @param" text1))))
                  (if (> (length text1) 0)
                      (progn
                        (goto-char (point-max))
                        (if (search-backward-regexp "^ +\\* *$" nil t)
                            (goto-char (line-end-position))
                          (progn
                            (goto-char (point-min))
                            (insert "/**\n*/\n")(backward-char 4)))
                        (insert param-text)
                        (indent-according-to-mode)
                        (insert "\n* ")
                        (indent-according-to-mode)))))))))
      (widen)))
#+END_SRC
*** ~phpunit~
#+BEGIN_SRC emacs-lisp
  (defun tom/php-unit ()
    ""
    (interactive)
    (let* ((pr (projectile-project-root))
           (confdir (concat pr "/tests"))
           (conf (concat confdir "/phpunit.xml"))
           (wd default-directory))
      (if (and (file-directory-p confdir) (file-exists-p conf))
          (progn
            (cd confdir)
            (phpunit-run '())
            (cd wd)))))
#+END_SRC

*** ~psysh~
#+BEGIN_SRC emacs-lisp
  (defun tom/psysh ()
      "Start or switch to a psysh specific to the current
          projectile project, or the global '*PsySh*' if not in a
          project"
    (interactive)
    (if (projectile-project-p)
        (let* ((-project-root (projectile-project-root))
               (-project (projectile-default-project-name -project-root))
               (-buffer-name (concat "* " -project " psysh *")))
          (psysh-run -buffer-name "psysh"))
      (psysh-run "*PsySh*" "psysh")))
#+END_SRC
** C
*** Indentation
#+BEGIN_SRC emacs-lisp
  (defun tom/c-mode-hook ()
    ""
    (setq tab-width 2
          c-basic-offset 2
          indent-tabs-mode nil)) 
  (add-hook 'c-mode-hook 'tom/c-mode-hook)
  
#+END_SRC
** JavaScript
*** Indentation etc
#+BEGIN_SRC emacs-lisp
  (if (tom/work?)
      (setq js-indent-level 4
            js2-basic-offset 4
            js2-bounce-indent-p t)
    (setq js-indent-level 2
          js2-basic-offset 2
          js2-bounce-indent-p t))
  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
#+END_SRC
*** Completion
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "/usr/lib/node_modules/tern/emacs")

  (defun tom/js2-mode-hook ()
    ""
    (progn
      (require 'tern)
      (require 'company-tern)

      (set (make-local-variable 'company-backends)
           '((company-tern :with :sorted company-yasnippet)))
      (ggtags-mode -1)
      (flycheck-mode 1)
      (repl-toggle-mode 1)
      (yas-minor-mode 1)
      (tern-mode t)
      (company-mode 1)
      (local-set-key (kbd "C-c a") 'tom/edit-aql)))
  (add-hook 'js2-mode-hook 'tom/js2-mode-hook)
#+END_SRC
*** Edit js in YAML-files
#+BEGIN_SRC emacs-lisp
  (defun tom/edit-js ()
    "If point is between a `^ body: > ... \\(^ - name: \\)\\|\\(^ types:\\)'
  block, create a narrowed, indirect buffer in `js2-mode' to edit the
  function-body.  Press `C-c C-c' inside the buffer to close the window
  and kill the indirect buffer."
    (interactive)
    (tom/edit-narrowed 'js2-mode ".js" "^        body: >" "\\(^      - name: \\)\\|\\(^    types:\\)"))
#+END_SRC
** YAML

Associate ~yaml-mode~ with formular (~.frm~) and table (~.tbl~)
definitions as used in fb-core et.al.

#+BEGIN_SRC emacs-lisp
  (require 'yaml-mode)
  (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
  (add-to-list 'auto-mode-alist '("\\.frm$" . yaml-mode))
  (add-to-list 'auto-mode-alist '("\\.tbl$" . yaml-mode))
  (defun tom/yaml-mode-hook ()
    ""
    (progn
      (setq tab-width 2
            c-basic-offset 2
            indent-tabs-mode nil)
      (yas-minor-mode 1)
      (aggressive-indent-mode -1)
      (local-set-key (kbd "C-c a") 'tom/edit-js)))
  (add-hook 'yaml-mode-hook 'tom/yaml-mode-hook)
#+END_SRC

** Groovy

#+BEGIN_SRC emacs-lisp
;;;  (require 'inf-groovy)
  (add-to-list 'auto-mode-alist '("\\.gvy$" . groovy-mode))
  (rtog/add-repl 'groovy-mode (rtog/switch-to-shell-buffer "*groovy*" 'run-groovy))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun tom/haskell-mode-hook ()
      ""
    (progn
      (hindent-mode 1)
      (aggressive-indent-mode -1)))

  (add-hook 'haskell-mode-hook 'tom/haskell-mode-hook)

  (let ((my-cabal-path (expand-file-name "~/.cabal/bin")))
    (setenv "PATH" (concat my-cabal-path path-separator (getenv "PATH")))
    (add-to-list 'exec-path my-cabal-path))
  (custom-set-variables '(haskell-tags-on-save t))
  (custom-set-variables
   '(haskell-process-suggest-remove-import-lines t)
   '(haskell-process-auto-import-loaded-modules t)
   '(haskell-process-log t)
   '(haskell-process-type 'cabal-repl)
   '(hindent-style "gibiansky"))

  (eval-after-load 'haskell-mode '(progn
                                   (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-or-reload)
                                   (define-key haskell-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
                                   (define-key haskell-mode-map (kbd "C-c C-n C-t") 'haskell-process-do-type)
                                   (define-key haskell-mode-map (kbd "C-c C-n C-i") 'haskell-process-do-info)
                                   (define-key haskell-mode-map (kbd "C-c C-n C-c") 'haskell-process-cabal-build)
                                   (define-key haskell-mode-map (kbd "C-c C-n c") 'haskell-process-cabal)))
  (eval-after-load 'haskell-cabal '(progn
                                     (define-key haskell-cabal-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
                                     (define-key haskell-cabal-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
                                     (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
                                     (define-key haskell-cabal-mode-map (kbd "C-c c") 'haskell-process-cabal)))
#+END_SRC

** AQL
#+BEGIN_SRC emacs-lisp
  (require 'aql-mode)
  (defun tom/aql-mode-hook ()
    ""
    (progn
      (setq tab-width 2
            c-basic-offset 2
            indent-tabs-mode nil)
      (yas-minor-mode 1)
      (aggressive-indent-mode -1)
      (local-set-key (kbd "C-c a") 'tom/edit-aql)))
  (add-hook 'aql-mode-hook 'tom/aql-mode-hook)
#+END_SRC
*** Edit AQL in ~js2-mode~
#+BEGIN_SRC emacs-lisp
  (defun tom/edit-aql ()
    "If point is inside a `aql\`...\`' block, create a narrowed,
  indirect buffer in `aql-mode' to edit the statement.  Press `C-c
  C-c' inside the buffer to close the window and kill the indirect
  buffer."
    (interactive)
    (tom/edit-narrowed 'aql-mode ".aql" "aql`" "`"))
#+END_SRC
** SQL
#+BEGIN_SRC emacs-lisp
  (require 'sql)
  (defun tom/sql-mode-hook ()
    ""
    (progn
      (setq tab-width 2
            c-basic-offset 2
            indent-tabs-mode nil)
      (yas-minor-mode 1)
      (aggressive-indent-mode nil)
      (local-set-key (kbd "C-c a") 'tom/edit-sql)
      (local-set-key (kbd "C-c C-c") 'sql-send-paragraph)))
  (add-hook 'sql-mode-hook 'tom/sql-mode-hook)
#+END_SRC
*** Edit SQL in ~php-mode~
#+BEGIN_SRC emacs-lisp
  (defun tom/edit-sql ()
    "If point is inside a `$source = \'...\';' block, create a narrowed,
        indirect buffer in `sql-mode' to edit the statement.  Press `C-c
        C-c' inside the buffer to close the window and kill the indirect
        buffer."
    (interactive)
    (tom/edit-narrowed 'sql-mode
                       ".sql"
                       "$\\(source\\|sql\\) = [\"']"
                       "[\"'];"
                       #'(lambda ()
                           (progn
                             (load-library "sql-indent")
                             (set (make-local-variable 'indent-line-function) 'sql-indent-line)
                             (setq sql-product "postgres")))))
#+END_SRC

* RESTful
** Extract json-field data
#+BEGIN_SRC emacs-lisp
  (defun tom/extract-json (name)
    "Extract the field `NAME' from the restclient-result buffer (`*HTTP Response*'). 
  Caution: This parses the hole buffer as json-data, so may be costly.

  `NAME' may be given as dotted path to address nested json-objects
  "
    (with-current-buffer "*HTTP Response*"
      (let* ((json-object-type 'hash-table)
             (json-array-type 'list)
             (json-key-type 'string)
             (names (split-string name "\\." t))
             (result nil)
             (data (json-read-from-string (buffer-string))))
        (reduce #'(lambda (value key) "" (gethash key value)) names :initial-value data))))
#+END_SRC

** Use ~outline-cycle~ in rest-buffers
#+BEGIN_SRC emacs-lisp
  (eval-after-load 'outline
    '(progn
       (require 'outline-magic)
       (define-key outline-minor-mode-map
         (kbd "<C-tab>")
         'outline-cycle)))
#+END_SRC
* Databases
** ElasticSearch
#+BEGIN_SRC emacs-lisp
  (autoload 'es-mode "es-mode.el" "Major mode for editing Elasticsearch queries." t)
  (add-to-list 'auto-mode-alist '("\\.es$" . es-mode))
  (add-hook 'es-result-mode-hook 'hs-minor-mode)
#+END_SRC
* Slime

#+BEGIN_SRC emacs-lisp
  ;;;(load (expand-file-name "~/quicklisp/slime-helper.el"))
  ;; Replace "sbcl" with the path to your implementation
  (setq inferior-lisp-program "sbcl")
#+END_SRC

* Version control
** Magit 
#+BEGIN_SRC emacs-lisp
  (require 'magit)
  (setq magit-last-seen-setup-instructions "1.4.0")
#+END_SRC
   
*** Key bindings
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f7>") 'magit-status)
#+END_SRC

*** Fullscreen

#+BEGIN_SRC emacs-lisp
(fullframe magit-status magit-mode-quit-window nil)
#+END_SRC

* Services
** =ssh= tunnel

Manage ssh tunnel via prodigy.

#+BEGIN_SRC emacs-lisp
(require 'prodigy)
#+END_SRC
*** Helper functions

**** Build the argument list

#+BEGIN_SRC emacs-lisp
  (defun tom/build-tunnel-args (args)
    "Assemble the ssh tunnel argument list."
    `("-v" ;; allows us to parse for the ready message
      "-N" ;; don't start an interactive shell remotely
      "-L" ,(concat (getf args :localport) ;; the tunnel spec
                    ":"
                    (getf args :tunnel-ip)
                    ":"
                    (getf args :tunnel-port))
      "-l" ,(getf args :user) ;; the username
      "-p" ,(getf args :port) ;; the remote port
      ,(getf args :host)))    ;; the remote host
#+END_SRC

*** Tunnel tag

#+BEGIN_SRC emacs-lisp
  (prodigy-define-tag
    :name 'ssh-tunnel
    :command "ssh"
    :cwd (getenv "HOME")
    :args (prodigy-callback (service)
            (tom/build-tunnel-args
             (getf service :tunnel)))
    :ready-message "debug1: Entering interactive session.")
#+END_SRC

*** Tunnel services

Tunnel definitions are held outside this config to protect the innocent...

#+BEGIN_SRC emacs-lisp
(load-file "~/ownCloud/dotfiles/prodigy.el")

#+END_SRC
** Work Services
#+BEGIN_SRC emacs-lisp
  (when (tom/work?)
    (load-file "~/ownCloud/dotfiles/workservices.el"))
#+END_SRC
* Paste services
** ix.io

#+BEGIN_SRC emacs-lisp
  (let ((ix-io (netrc-machine (netrc-parse "~/.netrc") "ix-io")))
    (setq ix-user (netrc-get ix-io "login"))
    (setq ix-token (netrc-get ix-io "password")))
#+END_SRC

** yagist

#+BEGIN_SRC emacs-lisp
  (let ((github (netrc-machine (netrc-parse "~/.netrc") "yagist")))
    (setq yagist-github-token (netrc-get github "password")))
#+END_SRC

* Search 
** the silver searcher

 I use ag.el to interact with ag, a fine replacement for grep.
 Ignore all ignore-files :-)

#+BEGIN_SRC emacs-lisp
(setq ag-arguments (list "-U" "--numbers" "--smart-case" "--nogroup" "--column" "--stats" "--"))
#+END_SRC

Focus on the current window and the ag-result buffer.

#+BEGIN_SRC emacs-lisp
(fullframe/split-screen ag quit-window "*ag search*" 'horizontal 't)
#+END_SRC

Delete the ~File:~ prefix appended by ~ag~ to the output, let `compile-find-file` work again.

#+BEGIN_SRC emacs-lisp
  (define-advice compilation-find-file (:around (orig-fun &rest args) remove-file-prefix -100)
    (let* ((to-find (car (cdr args)))
           (newname (s-replace "File: " "" to-find)))
      (setcar (cdr args) newname)
      (apply orig-fun args)))

#+END_SRC
* Passwords
*** Basic setup
 #+BEGIN_SRC emacs-lisp
   (require 'org-passwords)
   (setq org-passwords-file "~/.auth.gpg")
   (setq org-passwords-random-words-dictionary "/etc/dictionaries-common/words")
 #+END_SRC
*** capture template
 #+BEGIN_SRC emacs-lisp
   (require 'org-capture)
   (add-to-list 'org-capture-templates
                '("p" "password" entry (file "~/.auth.gpg")
                  "* %^{Title}\n  %^{URL}p %^{USERNAME}p %^{PASSWORD}p"))
 #+END_SRC
*** keybindings
 #+BEGIN_SRC emacs-lisp
   (eval-after-load "org-passwords"
     '(progn
        (define-key org-passwords-mode-map
          (kbd "C-c C-c")
          'org-passwords-copy-username)
        (define-key org-passwords-mode-map
          (kbd "C-c C-p")
          'org-passwords-copy-password)
        (define-key org-passwords-mode-map
          (kbd "C-c C-o")
          'org-passwords-open-url)))

 #+END_SRC

* Server
** httpd server
#+BEGIN_SRC emacs-lisp
  (setq httpd-port 8081)
#+END_SRC
** emacs server
Always have an emacs server running.

#+BEGIN_SRC emacs-lisp
(require 'server)
(unless (server-running-p)
  (org-reload) ; switch to newest org from melpa
  (server-start))
#+END_SRC

