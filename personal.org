
* Emacs rocks

This file contains my configurations and adaptations to
my now graphene based setup.

:PROPERTIES:
:tangle:	personal.el
:END:

* Packages

Package management and loading of utility packages.

** Management

Cask manages the packages installed.

#+BEGIN_SRC emacs-lisp
  (require 'cask "~/.cask/cask.el")
  (cask-initialize)
#+END_SRC

*** Pallet

Using =pallet= allows to use Cask and =M-x list-packages= together --
manual operations performed using =packages.el= are reflected in the
Cask file.

#+BEGIN_SRC emacs-lisp
(require 'pallet)
(pallet-mode t)
#+END_SRC

*** Code Loading

Recompile elisp code on load or require.

Since auto-compile is installed via cask, we cannot require it before
package Management is setup.

#+BEGIN_SRC emacs-lisp
  (setq load-prefer-newer t)
  (require 'auto-compile)
  (auto-compile-on-load-mode 1)
#+END_SRC

* Home <-> Work

Some things have to be configured differently depending on where I am -- at home or at work.

#+BEGIN_SRC emacs-lisp
  (defun tom/work? ()
    "Returns `T` if the current machine is at work, `NIL` otherwise"
    (file-exists-p (expand-file-name "~/.work")))
#+END_SRC

* Emacs =custom=

#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file)
#+END_SRC

* Helper functions
** Escape HTML entities

Basics found on ergoemacs.org.

#+BEGIN_SRC emacs-lisp
  (defun tom/replace-html-chars (text)
    "Replace “<” to “&lt;” and other chars in TEXT."
    (save-restriction      
      (with-temp-buffer
        (insert text)
        (goto-char (point-min))
        (while (search-forward "&" nil t) (replace-match "&amp;" nil t))
        (goto-char (point-min))
        (while (search-forward "<" nil t) (replace-match "&lt;" nil t))
        (goto-char (point-min))
        (while (search-forward ">" nil t) (replace-match "&gt;" nil t))
        (buffer-string))))
#+END_SRC

* Graphene

Stuff looted from graphene.
** helper functions
#+BEGIN_SRC emacs-lisp
  (defun kill-default-buffer ()
    "Kill the currently active buffer -- set to C-x k so that users are not asked which buffer they want to kill."
    (interactive)
    (let (kill-buffer-query-functions) (kill-buffer)))

  (defun kill-buffer-if-file (buf)
    "Kill a buffer only if it is file-based."
    (when (buffer-file-name buf)
      (when (buffer-modified-p buf)
          (when (y-or-n-p (format "Buffer %s is modified - save it?" (buffer-name buf)))
              (save-some-buffers nil buf)))
      (set-buffer-modified-p nil)
      (kill-buffer buf)))

  (defun kill-all-buffers ()
      "Kill all file-based buffers."
      (interactive)
      (mapc (lambda (buf) (kill-buffer-if-file buf))
       (buffer-list)))

  (defun kill-buffer-and-window ()
    "Close the current window and kill the buffer it's visiting."
    (interactive)
    (progn
      (kill-buffer)
      (delete-window)))

  (defun create-new-buffer ()
    "Create a new buffer named *new*[num]."
    (interactive)
    (switch-to-buffer (generate-new-buffer-name "*new*")))

  (defun insert-semicolon-at-end-of-line ()
    "Add a closing semicolon from anywhere in the line."
    (interactive)
    (save-excursion
      (end-of-line)
      (insert ";")))

  (defun tom/comment-line-dwim (n)
    "Comment or uncomment current line and leave point after
  it. With positive prefix, apply to N lines including current
  one. With negative prefix, apply to -N lines above."
    (interactive "p")
    (comment-or-uncomment-region
     (line-beginning-position)
     (goto-char (line-end-position n)))
    (forward-line 1) (back-to-indentation))

  (defun comment-current-line-dwim ()
    "Comment or uncomment the current line."
    (interactive)
    (save-excursion
      (push-mark (beginning-of-line) t t)
      (end-of-line)
      (comment-dwim nil)))

  (defun newline-anywhere ()
    "Add a newline from anywhere in the line."
    (interactive)
    (end-of-line)
    (newline-and-indent))

  (defun increase-window-height (&optional arg)
    "Make the window taller by one line. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window arg))

  (defun decrease-window-height (&optional arg)
    "Make the window shorter by one line. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window (- 0 arg)))

  (defun decrease-window-width (&optional arg)
    "Make the window narrower by one column. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window (- 0 arg) t))

  (defun increase-window-width (&optional arg)
    "Make the window wider by one column. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window arg t))

  ;; Create a new instance of emacs
  (when window-system
    (defun new-emacs-instance ()
      (interactive)
      (let ((path-to-emacs
             (locate-file invocation-name
                          (list invocation-directory) exec-suffixes)))
        (call-process path-to-emacs nil 0 nil))))

#+END_SRC
** editing

#+BEGIN_SRC emacs-lisp
  ;;(delete-selection-mode t)
  (global-visual-line-mode t)
  (setq linum-format " %4d ")
  (setq-default tab-width 2)
  (setq-default indent-tabs-mode nil)
  (prefer-coding-system 'utf-8)
  (set-language-environment 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)

  (linum-mode t)

  (show-paren-mode t)
  (setq blink-matching-paren t)
  (electric-pair-mode t)

  (require 'flycheck)
  (flycheck-mode)

  (push '("\\.json\\'" . json-mode) auto-mode-alist)

  ;; don't compile sass/scss on saving
  (setq scss-compile-at-save nil)

  ;; 2-space indent for CSS
  (setq css-indent-offset 2)

  ;; Default Ruby filetypes
  (dolist (regex
           '("\\.watchr$" "\\.arb$" "\\.rake$" "\\.gemspec$" "\\.ru$" "Rakefile$" "Gemfile$" "Capfile$" "Guardfile$" "Rakefile$" "Cheffile$" "Vagrantfile$"))
    (add-to-list 'auto-mode-alist `(,regex . ruby-mode)))

  ;; Remap newline to newline-and-indent in ruby-mode
  (add-hook 'ruby-mode-hook
            (lambda ()
              (define-key (current-local-map) [remap newline] 'reindent-then-newline-and-indent)))

#+END_SRC
** env
#+BEGIN_SRC emacs-lisp
  (require 'smex)
  (require 'flx-ido)
  (smex-initialize)

  (setq inhibit-startup-message t
        color-theme-is-global t
        uniquify-buffer-name-style 'forward
        backup-directory-alist `((".*" . ,temporary-file-directory))
        auto-save-file-name-transforms `((".*" ,temporary-file-directory t))
        ido-mode 1
        flx-ido-mode 1
        ido-enable-flex-matching t
        ido-auto-merge-work-directories-length nil
        ido-create-new-buffer 'always
        ido-use-filename-at-point 'guess
        ido-everywhere t
        ido-use-faces nil)

  (fset 'yes-or-no-p 'y-or-n-p)

  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)

  (global-auto-revert-mode t)

  (ido-mode 1)

  (put 'ido-complete 'disabled nil)
  (put 'ido-exit-minibuffer 'disabled nil)
  (put 'dired-find-alternate-file 'disabled nil)
  (put 'autopair-newline 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
#+END_SRC
** speedbar
#+BEGIN_SRC emacs-lisp
  (autoload 'sr-speedbar-open "sr-speedbar" "Open the in-frame speedbar" t)

  (eval-after-load 'sr-speedbar
    '(progn
       (setq speedbar-hide-button-brackets-flag t
             speedbar-show-unknown-files t
             speedbar-smart-directory-expand-flag t
             speedbar-directory-button-trim-method 'trim
             speedbar-use-images nil
             speedbar-indentation-width 2
             speedbar-use-imenu-flag t
             speedbar-file-unshown-regexp "flycheck-.*"
             sr-speedbar-width 40
             sr-speedbar-width-x 40
             sr-speedbar-auto-refresh nil
             sr-speedbar-skip-other-window-p t
             sr-speedbar-right-side nil)

       ;; Refresh the speedbar when relevant hooks are run.
       (defvar tom/speedbar-refresh-hooks)
       (defvar tom/speedbar-refresh-hooks-added nil
         "Whether hooks have been added to refresh speedbar.")

       (add-hook 'speedbar-mode-hook
                 '(lambda ()
                    (hl-line-mode 1)
                    (visual-line-mode -1)
                    (setq automatic-hscrolling nil)
                    (let ((speedbar-display-table (make-display-table)))
                      (set-display-table-slot speedbar-display-table 0 8230)
                      (setq buffer-display-table speedbar-display-table))
                    (when (not tom/speedbar-refresh-hooks-added)
                      (lambda ()
                        (mapc (lambda (hook)
                                (add-hook hook 'speedbar-refresh))
                              tom/speedbar-refresh-hooks)
                        (setq tom/speedbar-refresh-hooks-added t)))))

       ;; More familiar keymap settings.
       (add-hook 'speedbar-reconfigure-keymaps-hook
                 '(lambda ()
                    (define-key speedbar-mode-map [S-up] 'speedbar-up-directory)
                    (define-key speedbar-mode-map [right] 'speedbar-flush-expand-line)
                    (define-key speedbar-mode-map [left] 'speedbar-contract-line)))

       ;; Pin and unpin the speedbar
       (defvar tom/speedbar-pinned-directory)

       (defadvice speedbar-update-directory-contents
         (around tom/speedbar-pin-directory activate disable)
         "Pin the speedbar to the directory set in tom/speedbar-pinned-directory."
         (let ((default-directory tom/speedbar-pinned-directory))
           ad-do-it))

       (defadvice speedbar-dir-follow
         (around tom/speedbar-prevent-follow activate disable)
         "Prevent speedbar changing directory on button clicks."
         (speedbar-toggle-line-expansion))

       (defadvice speedbar-directory-buttons-follow
         (around tom/speedbar-prevent-root-follow activate disable)
         "Prevent speedbar changing root directory on button clicks.")

       (defvar tom/speedbar-pin-advice
         '((speedbar-update-directory-contents around tom/speedbar-pin-directory)
           (speedbar-dir-follow around tom/speedbar-prevent-follow)
           (speedbar-directory-buttons-follow around tom/speedbar-prevent-root-follow))
         "Advice to be enabled and disabled on tom/[un]-pin-speedbar.")

       (defun tom/speedbar-pin-advice-activate ()
         "Activate the advice applied to speedbar functions in order to pin it to a directory."
         (mapc 'ad-activate (mapcar 'car tom/speedbar-pin-advice)))

       (defun tom/pin-speedbar (directory)
         "Prevent the speedbar from changing the displayed root directory."
         (setq tom/speedbar-pinned-directory directory)
         (mapc (lambda (ls) (apply 'ad-enable-advice ls)) tom/speedbar-pin-advice)
         (tom/speedbar-pin-advice-activate))

       (defun tom/unpin-speedbar ()
         "Allow the speedbar to change the displayed root directory."
         (mapc (lambda (ls) (apply 'ad-disable-advice ls)) tom/speedbar-pin-advice)
         (tom/speedbar-pin-advice-activate))

       ;; Always use the last selected window for loading files from speedbar.
       (defvar last-selected-window
         (if (not (eq (selected-window) sr-speedbar-window))
             (selected-window)
           (other-window 1)))

       (defadvice select-window (after remember-selected-window activate)
         "Remember the last selected window."
         (unless (or (eq (selected-window) sr-speedbar-window)
                     (not (window-live-p (selected-window))))
           (setq last-selected-window (selected-window))))

       (defun sr-speedbar-before-visiting-file-hook ()
         "Function that hooks `speedbar-before-visiting-file-hook'."
         (select-window last-selected-window))

       (defun sr-speedbar-before-visiting-tag-hook ()
         "Function that hooks `speedbar-before-visiting-tag-hook'."
         (select-window last-selected-window))

       (defun sr-speedbar-visiting-file-hook ()
         "Function that hooks `speedbar-visiting-file-hook'."
         (select-window last-selected-window))

       (defun sr-speedbar-visiting-tag-hook ()
         "Function that hooks `speedbar-visiting-tag-hook'."
         (select-window last-selected-window))))

#+END_SRC
** keys
#+BEGIN_SRC emacs-lisp

(global-set-key (kbd "C-x k")
                'kill-default-buffer)
(global-set-key (kbd "C-x C-k")
                'kill-buffer-and-window)
(global-set-key (kbd "C-c n")
                'create-new-buffer)
(global-set-key (kbd "C-c N")
                'new-emacs-instance)
(global-set-key (kbd "C-;")
                'insert-semicolon-at-end-of-line)
(global-set-key (kbd "M-RET")
                'newline-anywhere)
(global-set-key (kbd "M-C-;")
                'tom/comment-line-dwim)
(global-set-key (kbd "C->")
                'increase-window-height)
(global-set-key (kbd "C-<")
                'decrease-window-height)
(global-set-key (kbd "C-,")
                'decrease-window-width)
(global-set-key (kbd "C-.")
                'increase-window-width)
(global-set-key (kbd "M-x")
                'smex)
(global-set-key (kbd "M-X")
                'smex-major-mode-commands)
(global-set-key (kbd "C-c s")
                'sr-speedbar-select-window)

#+END_SRC
** look
#+BEGIN_SRC emacs-lisp
;; Work around Emacs frame sizing bug when line-spacing
;; is non-zero, which impacts e.g. grizzl.
(add-hook 'minibuffer-setup-hook
          (lambda ()
            (set (make-local-variable 'line-spacing) 0)
            (setq resize-mini-windows (featurep 'ido-vertical-mode))))

(setq redisplay-dont-pause t)
#+END_SRC
* Global stuff
** Single frame execution
#+BEGIN_SRC emacs-lisp
  (require 'fullframe)
#+END_SRC



** Key bindings
   :PROPERTIES:
   :ID:       b186cad4-7355-4c52-a1a2-21f52a49aa5f
   :END:
 - Meta-Pause will delete the current frame
 - use f2 as tool-bar toggle (analog to f1 for menu-bar-mode)
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-<pause>") 'delete-frame)
  (global-set-key (kbd "<f1>") 'menu-bar-mode)
  (global-set-key (kbd "<f2>") 'tool-bar-mode)
  (global-set-key (kbd "<f5>") 'flyspell-mode)
  (global-set-key (kbd "<f6>") 'flyspell-prog-mode)
  (global-set-key (kbd "<f9>") 'flymake-mode)
#+END_SRC

 
*** launcher map 

Launch seldom used emacs tools via C-x l <KEY>.

Inspired/copied from endless parentheses blog

#+BEGIN_SRC emacs-lisp
(define-prefix-command 'launcher-map)
;; The manual recommends C-c for user keys, but C-x l is
;; always free and is natural to remember.
(define-key ctl-x-map "l" 'launcher-map)
(global-set-key (kbd "s-l") 'launcher-map)
(define-key launcher-map "c" #'calc)
(define-key launcher-map "d" #'ediff-buffers)
(define-key launcher-map "f" #'find-dired)
(define-key launcher-map "g" #'git-timemachine)
(define-key launcher-map "G" #'rgrep)
(define-key launcher-map "h" #'man) ; Help
(define-key launcher-map "i" #'package-install-from-buffer)
(define-key launcher-map "n" #'nethack)
(define-key launcher-map "p" #'list-packages)
(define-key launcher-map "s" #'shell)
(define-key launcher-map "t" #'proced) ; top
#+END_SRC

*** Toggle states

#+BEGIN_SRC emacs-lisp
(define-prefix-command 'tom/toggle-map)
;; The manual recommends C-c for user keys, but C-x t is
;; always free, whereas C-c t is used by some modes.
(define-key ctl-x-map "t" 'tom/toggle-map)
(define-key tom/toggle-map "c" 'column-number-mode)
(define-key tom/toggle-map "d" 'toggle-debug-on-error)
(define-key tom/toggle-map "e" 'toggle-debug-on-error)
(define-key tom/toggle-map "f" 'auto-fill-mode)
(define-key tom/toggle-map "l" 'toggle-truncate-lines)
(define-key tom/toggle-map "q" 'toggle-debug-on-quit)
; (define-key tom/toggle-map "t" 'tom/toggle-theme)
;;; Generalized version of `read-only-mode'.
(define-key tom/toggle-map "r" 'dired-toggle-read-only)
(autoload 'dired-toggle-read-only "dired" nil t)
#+END_SRC

**** Narrowing

#+BEGIN_SRC emacs-lisp
  (defun narrow-or-widen-dwim (p)
    "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
  Intelligently means: region, org-src-block, org-subtree, or defun,
  whichever applies first.
  Narrowing to org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer is already
  narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing command.
           ;; Remove this first conditional if you don't want it.
           (cond ((org-in-src-block-p)
                  (org-edit-src-code)
                  (delete-other-windows))
                 ((org-at-block-p)
                  (org-narrow-to-block))
                 (t (org-narrow-to-subtree))))
          (t (narrow-to-defun))))

  (define-key tom/toggle-map "n" #'narrow-or-widen-dwim)
  ;; This line actually replaces Emacs' entire narrowing keymap, that's
  ;; how much I like this command. Only copy it if that's what you want.
  ;;(define-key ctl-x-map "n" #'narrow-or-widen-dwim)
#+END_SRC

** Undo as tree

#+BEGIN_SRC emacs-lisp
  (global-undo-tree-mode)
#+END_SRC
** yasnippet Setup

   A few variables to be used in snippets.
#+BEGIN_SRC emacs-lisp
  (setq fb-author "tregner")
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (require 'yasnippet)
  (yas-reload-all)
#+END_SRC
* GPG setup

GPG is handled almost transparently in emacs nowadays; this setup
helps for remote sessions.

<wgreenhouse> tomterl: this assumes emacsclient/emacs --daemon are      [15:35]
    invoked from a shell that is properly setting GPG_AGENT_INFO
    already
<wgreenhouse> but according to documentation, GPG_TTY needs to be
    adjusted for each terminal
> wgreenhouse: thanks -- should be the case, I'll make a note
<taylanub> "arc4random_uniform(9000) + 1000" should give me a good      [15:36]
    4-digit random number, right ?
<wgreenhouse> tomterl: also, I really don't like it because it will     [15:38]
    screw up DISPLAY for any jobs started from the gui emacsclient
    when I am back at that machine
> wgreenhouse: Yepp - we see, when I have the time to tackle gpg,       [15:39]
    maybe I find a cleaner solution
<baboon`> how can I call several functions over a single selection
    without re-selecting between each


(defun tom/kludge-gpg-agent (frame)
  (unless (display-graphic-p)
    (setenv "DISPLAY" nil)
    (setenv "GPG_TTY" (terminal-name frame))))

(add-hook 'after-make-frame-functions 'wg/kludge-gpg-agent)

* Languages
** Elixir

Use =elixir-mix-mode= where applicable.

#+BEGIN_SRC emacs-lisp
  (require 'elixir-mix)
  (global-elixir-mix-mode)
#+END_SRC

Automatically add =end= when typing =do=.

#+BEGIN_SRC emacs-lisp
  (require 'elixir-mode)
  (add-to-list
   'elixir-mode-hook
   (defun auto-activate-ruby-end-mode-for-elixir-mode ()
     (set (make-variable-buffer-local 'ruby-end-expand-keywords-before-re)
          "\\(?:^\\|\\s-+\\)\\(?:do\\)")
     (set (make-variable-buffer-local 'ruby-end-check-statement-modifiers) nil)
     (ruby-end-mode +1)))
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (defun tom/elixir-mode-hook ()
    ""
    (progn 
      (require 'alchemist)
      (set (make-local-variable 'company-backends)
           '((Alchemist-company :with company-yasnippet company-dabbrev-code)))
      (flycheck-mode 1)
      (yas-minor-mode 1)))
          (add-hook 'elixir-mode-hook 'tom/elixir-mode-hook)

#+END_SRC
*** Imenu 

Add speedbar support for elixir files.

#+BEGIN_SRC emacs-lisp
  (require 'speedbar)
  (speedbar-add-supported-extension ".ex")
  (speedbar-add-supported-extension ".exs")
#+END_SRC

** PHP
*** Use php-mode, not web-mode

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.php$" . php-mode))
  (add-to-list 'auto-mode-alist '("\\.inc$" . php-mode))
#+END_SRC

*** Indentation and behaviour

Indent with 4 spaces. Use flycheck, but dont't use the "controversial" and "cleancode" rulesets of phpmd.

#+BEGIN_SRC emacs-lisp
  (defun tom/php-mode-hook ()
    ""
    (progn 
      (setq tab-width 4
            c-basic-offset 4
            indent-tabs-mode nil
            php-template-compatibility nil
            flycheck-phpmd-rulesets '("codesize" "design" "naming" "unusedcode"))
      (set (make-local-variable 'company-backends)
           '((company-gtags :with company-yasnippet company-dabbrev-code)))
      (ggtags-mode 1)
      (flycheck-mode 1)
      (yas-minor-mode 1)))
  (add-hook 'php-mode-hook 'tom/php-mode-hook)
#+END_SRC
*** Remote debugging

Geben is old and un(der)maintained, but it works...

 #+BEGIN_SRC emacs-lisp
   (setq geben-dbgp-default-port 9000)
 #+END_SRC

Reroute remote paths to my dev-server and the vagrant user.

#+BEGIN_SRC emacs-lisp
  (defun tom/geben-tramp-spec (remote-path)
    ""
    (print "/sshx:vagrant@192.168.254.254:"))
  (fset 'geben-get-tramp-spec-for 'tom/geben-tramp-spec)
#+END_SRC
*** Check/correct @param tags
Check the doc comment of the current function for @param tags, create them if not present.

#+BEGIN_SRC emacs-lisp
  (defun tom/php-check-params ()
    ""
    (interactive)
    (save-excursion
      (narrow-to-defun t)
      (goto-char (point-min))
      (search-forward-regexp "function[^(]*(\\(.*\\))\\(?:;\\| {\\)")
      (let ((params (split-string (match-string-no-properties 1) ", " t " ")))
        (dolist (param (reverse params))
          (let* ((parts (split-string param " "))
                 (pname (if (cadr parts) (cadr parts) (car parts)))
                 (param-parts (split-string pname "=" t " "))
                 (type (if (cadr parts) (car parts) nil))
                 (name (car param-parts))
                 (default (cadr param-parts))
                 (typemsg (if type type (if (numberp default) "int" "")))
                 (defaultmsg (if default
                                 (concat "optional, default '"
                                         (if (numberp default)
                                             (number-to-string default)
                                           default)
                                         "'")
                               "")))
            (save-excursion
              (unless (search-backward-regexp (concat "@param .*" name) nil t)
                (let* ((text1 (s-trim (s-join " " (list typemsg name defaultmsg))))
                       (param-text (s-join " " (list "\n* @param" text1))))
                  (if (> (length text1) 0)
                      (progn (if (search-backward "/**" nil t)
                                 (forward-char 3)
                               (progn (goto-char (point-min))(insert "/**\n*/\n")(backward-char 4)))
                             (insert param-text)
                             (indent-according-to-mode)))))))))
      (widen)))
#+END_SRC
** C
*** Indentation
#+BEGIN_SRC emacs-lisp
  (defun tom/c-mode-hook ()
    ""
    (setq tab-width 2
          c-basic-offset 2
          indent-tabs-mode t))
  (add-hook 'c-mode-hook 'tom/c-mode-hook)
  
#+END_SRC
** Lisp

Lambda as λ

#+BEGIN_SRC emacs-lisp
  (defmacro λ (&rest body)
    `(lambda ()
       (interactive)
       ,@body))
  
  (global-set-key (kbd "H-l") (λ (insert "\u03bb")))
#+END_SRC
** JavaScript

#+BEGIN_SRC emacs-lisp
  (setq js-indent-level 2)
#+END_SRC

** YAML

Associate ~yaml-mode~ with formular (~.frm~) and table (~.tbl~)
definitions as used in fb-core et.al.

#+BEGIN_SRC emacs-lisp
  (require 'yaml-mode)
  (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
  (add-to-list 'auto-mode-alist '("\\.frm$" . yaml-mode))
  (add-to-list 'auto-mode-alist '("\\.tbl$" . yaml-mode))
#+END_SRC
* Emacs shell

I use =vim= and =htop=, so let's add those to =eshell-visual-commands=. 

#+BEGIN_SRC emacs-lisp
  (require 'eshell)
  (require 'em-term)
  (add-to-list 'eshell-visual-commands "htop")
  (add-to-list 'eshell-visual-commands "vim")
#+END_SRC

I like it to switch to the shell with one keystroke

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c C-S-s") 'eshell)
#+END_SRC

* Completion

I use ~company-mode~ as completion system. For most languages I use
the newer GNU global -- with pygmentize backend -- to provide tags for
code traversal and (additional) completion.

** Configure ~company-mode~

Use ~company-mode~ globally.

I live in a case sensitive world, so don't alter the case of
completions, but provide completions without regard for the case fo
the stuff I entered.

#+BEGIN_SRC emacs-lisp
                                          ;(global-auto-complete-mode -1)
  (require 'company)
  (add-hook 'after-init-hook 'global-company-mode)
  (setq company-dabbrev-downcase nil
        company-dabbrev-ignore-case t)
#+END_SRC
*** Key bindings

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "H-SPC") 'company-complete)
#+END_SRC

** GNU global

#+BEGIN_SRC emacs-lisp
(defun gtags-root-dir ()
    "Returns GTAGS root directory or nil if doesn't exist."
    (with-temp-buffer
      (if (zerop (call-process "global" nil t nil "-pr"))
          (buffer-substring (point-min) (1- (point-max)))
        nil)))

(defun gtags-update ()
    "Make GTAGS incremental update"
    (call-process "global" nil nil nil "-u"))

(defun gtags-root-dir ()
    "Returns GTAGS root directory or nil if doesn't exist."
    (with-temp-buffer
      (if (zerop (call-process "global" nil t nil "-pr"))
          (buffer-substring (point-min) (1- (point-max)))
        nil)))

(defun gtags-update-single(filename)  
      "Update Gtags database for changes in a single file"
      (interactive)
      (start-process "update-gtags" "update-gtags" "bash" "-c" (concat "cd " (gtags-root-dir) " ; gtags --single-update " filename )))

(defun gtags-update-current-file()
      (interactive)
      (defvar filename)
      (setq filename (replace-regexp-in-string (gtags-root-dir) "." (buffer-file-name (current-buffer))))
      (gtags-update-single filename)
      (message "Gtags updated for %s" filename))

(defun gtags-update-hook()
      "Update GTAGS file incrementally upon saving a file"
      (when (and (boundp 'ggtags-mode) ggtags-mode)
        (when (gtags-root-dir)
          (gtags-update-current-file))))

(add-hook 'after-save-hook 'gtags-update-hook)
#+END_SRC
* Projects

** projectile

Use projectile automatically.
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook (λ () (progn (require 'dash)(projectile-mode 1))))
#+END_SRC 

#+BEGIN_SRC emacs-lisp
  (setq projectile-switch-project-action 'projectile-find-dir)
  (setq projectile-find-dir-includes-top-level t)
#+END_SRC
*** Keys
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "H-p") 'projectile-commander)

#+END_SRC
*** deprecated
The following is old graphene/project-persist related stuff; should go.

#+BEGIN_SRC emacs-lisp
;  (add-hook 'project-persist-after-load-hook
;        (add-hook 'prog-mode-hook (λ () (projectile-mode 1)))
;  (add-hook 'project-persist-after-close-hook
;            (λ () (projectile-mode -1)))
#+END_SRC

* Appearance
** Font

#+BEGIN_SRC emacs-lisp
  (defvar tom/default-font "-unknown-Ubuntu Mono-normal-normal-normal-*-12-*-*-*-m-0-iso10646-1"
    "The font to use under normal circumstances")
  (defvar tom/fallback-font "-unknown-Symbola-normal-normal-semicondensed-*-12-*-*-*-*-0-iso10646-1"
    "Font to use, if the default font misses a glyph.")

  (set-frame-font tom/default-font t t)


  (setq default-frame-alist `((font . ,tom/default-font)))

  (set-fontset-font "fontset-default" '(#x10000 . #x1ffff) tom/fallback-font)

  (add-hook
   'after-make-frame-functions
   (lambda (frame)
     (set-fontset-font "fontset-default"
                       '(#x10000 . #x1ffff) tom/fallback-font frame)))

#+END_SRC

** Fontlock et.al.
   :PROPERTIES:
   :ID:       7edcd500-dcee-4484-9f44-9a65a3f29c71
   :END:

#+BEGIN_SRC emacs-lisp
  (global-font-lock-mode 1)
  (global-hl-line-mode -1)
  (line-number-mode 1)
  (column-number-mode 1)
  (setq mouse-buffer-menu-mode-mult 1)
#+END_SRC

** Scrollbar
   :PROPERTIES:
   :ID:       88e6ec5b-6aa6-4e18-b25e-7b2756d0918f
   :END:

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'scroll-bar-mode)
    (scroll-bar-mode -1))
#+END_SRC

** Menu and Toolbar

#+BEGIN_SRC emacs-lisp
  (when (fboundp tool-bar-mode)
    (tool-bar-mode -1))
  (when (fboundp menu-bar-mode)
    (menu-bar-mode -1))
#+END_SRC

** Color Theme
   :PROPERTIES:
   :ID:       eb979d64-dc35-4bdd-879c-9a73408096f2
   :END:

My current dark theme.

#+BEGIN_SRC emacs-lisp
  (load-theme 'ample t)
#+END_SRC
*** Adapt company-mode
#+BEGIN_SRC emacs-lisp
  (require 'color)

  (let ((bg (face-attribute 'default :background))
        (fg (face-attribute 'default :foreground)))
    (custom-set-faces
     `(company-tooltip ((t (:inherit default :background ,(color-lighten-name bg 15)))))
     `(company-scrollbar-bg ((t (:background ,(color-lighten-name bg 10)))))
     `(company-scrollbar-fg ((t (:background ,(color-lighten-name bg 5)))))
     `(company-tooltip-selection ((t (:inherit font-lock-function-name-face))))
     `(company-tooltip-common ((t (:inherit default :background ,(color-lighten-name bg 10) :foreground ,(color-darken-name fg 20)))))))
#+END_SRC
** TreeView

*** Show nice(?) icons

#+BEGIN_SRC emacs-lisp
(setq tree-widget-image-enable 1)
#+END_SRC

** Modeline

#+BEGIN_SRC emacs-lisp
  (sml/setup)
  (sml/apply-theme 'dark)
  ;;(powerline-default-theme)
#+END_SRC

** Colors on terminals

#+BEGIN_SRC emacs-lisp
(require 'color-theme-approximate)
#+END_SRC

** Highlight uncommited changes
Show uncomitted changes in the fringe.
#+BEGIN_SRC emacs-lisp
  (require 'diff-hl)
  (global-diff-hl-mode)
  (defadvice magit-mode-quit-window (after update-diff-hl-after-commit activate)
    (diff-hl-update))
#+END_SRC
** Whitespace visualization

I find it unnecessary to mark normal spaces, but to visualize tab
characters and newlines is a possible lifesaver.

#+BEGIN_SRC emacs-lisp
  (setq whitespace-display-mappings
        '(
          (newline-mark 10 [8629 10])
          (tab-mark 9 [8677 9] [92 9])
          ))
  
          (setq whitespace-style '(face tabs newline tab-mark newline-mark))
  
  (global-whitespace-mode)
#+END_SRC

	
** Hide the mode line

This is interesting for presentations (e.g.).

#+BEGIN_SRC emacs-lisp
(defvar-local hidden-mode-line-mode nil)
(defvar-local hide-mode-line nil)

(define-minor-mode hidden-mode-line-mode
  "Minor mode to hide the mode-line in the current buffer."
  :init-value nil
  :global nil
  :variable hidden-mode-line-mode
  :group 'editing-basics
  (if hidden-mode-line-mode
      (setq hide-mode-line mode-line-format
            mode-line-format nil)
    (setq mode-line-format hide-mode-line
          hide-mode-line nil))
  (force-mode-line-update)
  ;; Apparently force-mode-line-update is not always enough to
  ;; redisplay the mode-line
  (redraw-display)
  (when (and (called-interactively-p 'interactive)
             hidden-mode-line-mode)
    (run-with-idle-timer
     0 nil 'message
     (concat "Hidden Mode Line Mode enabled.  "
             "Use M-x hidden-mode-line-mode to make the mode-line appear."))))
#+END_SRC

** Minimap

This is a birds eye view of the current buffer.

#+BEGIN_SRC emacs-lisp
  (setq minimap-dedicated-window t
       minimap-hide-scroll-bar t
       minimap-hide-fringes t
       )
  (global-set-key (kbd "H-M") 'minimap-toggle)
  
#+END_SRC

** Fringe
#+BEGIN_SRC emacs-lisp
(fringe-mode (cons nil  8))
#+END_SRC

* GNUS News and Mail

#+BEGIN_SRC emacs-lisp
  (defun tom/gnus ()
    "Setup and start GNUS"
    (interactive)
    (setq tom/--gnus-home (expand-file-name "gnus" tom/--src-base))
    (let ((lisp-dir (expand-file-name "lisp" tom/--gnus-home)))
      (when (file-directory-p lisp-dir)
        (add-to-list 'load-path lisp-dir)
        (require 'gnus-load)
        (load-file (expand-file-name "gnus-util.elc" lisp-dir)))
      
      ;;(require 'gnus)
      (require 'smtpmail)
      (require 'nnimap)
      (if (tom/work?)
          (progn
            (setq user-mail-address "thomas.regner@fb-research.de")
            (setq user-full-name "Tom Regner")
            (setq smtpmail-smtp-server "omega"
                  send-mail-function 'smtpmail-send-it)
            (setq message-send-mail-function 'smtpmail-send-it)
            (setq smtpmail-smtp-service 25))
        (progn
          (setq user-mail-address "tom@goochesa.de")
          (setq user-full-name "Tom Regner")
          (setq smtpmail-smtp-server "sec.goochesa.de"
                send-mail-function 'smtpmail-send-it)
          (setq message-send-mail-function 'smtpmail-send-it)
          (setq smtpmail-smtp-service 25))
        
        )
      (setq
       starttls-use-gnutls t
       starttls-gnutls-program "gnutls-cli"
       starttls-extra-arguments "")
      (setq smtpmail-debug-info t)
      (setq smtpmail-debug-verb t)
      
      
      ;; display nice arrows in thread-view (summary buffer)
      ;; the font must have the glyphs!
      (setq-default
       gnus-summary-line-format "%U%R%z %(%&user-date;  %-15,15f %* %B%-80,80s%)\n"
       gnus-user-date-format-alist '((t . "%d.%m.%Y %H:%M"))
       gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references
       gnus-thread-sort-functions '(gnus-thread-sort-by-date)
       gnus-sum-thread-tree-false-root ""
       gnus-sum-thread-tree-indent " "
       gnus-sum-thread-tree-leaf-with-other "├► "
       gnus-sum-thread-tree-root ""
       gnus-sum-thread-tree-single-leaf "╰► "
       gnus-sum-thread-tree-vertical "│"
       )
      
      (setq gnus-select-method
            (if (not (tom/work?))
                '(nnimap "tomsdiner"
                         (nnimap-address "mail.tomsdiner.org")
                         (nnimap-server-port 993)
                         (nnimap-authinfo-file (expand-file-name "~/.authinfo"))
                         (nnimap-stream ssl)
                         )
              '(nnimap "franke & bornberg"
                       (nnimap-address "omega")
                       (nnimap-server-port 143)
                       (nnimap-authinfo-file (expand-file-name "~/.authinfo"))
                       (nnimap-stream network)
                       )
              ))
      (if (not (tom/work?))
          (setq gnus-secondary-select-methods
                '(
                  (nnimap "Goochesa"
                          (nnimap-address "sec.goochesa.de")
                          (nnimap-authinfo-file (expand-file-name "~/.authinfo"))
                          (nnimap-stream tls)
                                          ;                    (nnimap-server-port 993)
                                          ;                    (nnimap-authenticator "plain")
                          )
                  )))
      ;; (setq gnus-secondary-select-methods
      ;;       '(
      ;;         ;; (nnimap "Joocom"
      ;;         ;;          (nnimap-address "127.0.0.1")
      ;;         ;;          (nnimap-server-port 20251)
      ;;         ;;          (nnimap-authinfo-file (expand-file-name "~/.authinfo"))
      ;;         ;;          (nnimap-stream ssl)
      ;;         ;;          (nnimap-authenticator "login")
      ;;         ;;          )
      ;;         (nntp "news.t-online.de")
      ;;         )
      ;;       )
      
      
      ;; lez gnus-demon check for new news and mail every 5mins, if emacs
      ;; is idle
      (defun gnus-demon-scan-mail-or-news-and-update ()
        "Scan for new mail/news and update the *Group* buffer"
        (when (gnus-alive-p)
          (save-window-excursion
            (save-excursion
              (set-buffer gnus-group-buffer)
              (gnus-group-get-new-news)))))
      
      (defun gnus-demon-scan-and-update ()
        (gnus-demon-scan-mail-or-news-and-update))
      
      ;; (gnus-demon-add-handler 'gnus-demon-scan-and-update nil 5)
      ;; (setq gnus-use-demon t)
      ;; (gnus-demon-init)
      
      ;; (gnus-demon-add-scanmaoupil)
      (gnus))

    (require 'ldap)
    (require 'eudc)

    (setq eudc-default-return-attributes nil
          eudc-strict-return-matches nil)

    (setq ldap-ldapsearch-args (quote ("-P" "3" "-LL" "-x")))
    (setq eudc-inline-query-format '((name)
                                     (firstname)
                                     (firstname name)
                                     (mail)
                                     ))

    (if (tom/work?)
        (progn
          (let ((ldapv (netrc-machine (netrc-parse "~/.netrc") "ldapv")))
            (setq ldap-host-parameters-alist
                  `(("omega" base "OU=SBSUsers,OU=Users,OU=MyBusiness,DC=fbr-zentrale,DC=local"
                     binddn ,(netrc-get ldapv "login")
                     passwd ,(netrc-get ldapv "password")
                     port 389
                     ))))
          (setq ldap-default-host "omega")
          (eudc-set-server "omega" 'ldap t)
          (setq eudc-server-hotlist '(("omega" . ldap)))
          (setq eudc-inline-expansion-servers 'hotlist)

          (defun enz-eudc-expand-inline()
            (interactive)
            (move-end-of-line 1)
            (insert "*")
            (unless (condition-case nil
                        (eudc-expand-inline)
                      (error nil))
              (backward-delete-char-untabify 1)))))
    ;; Adds some hooks

    (eval-after-load "message"
      '(define-key message-mode-map (kbd "TAB") 'enz-eudc-expand-inline))
    (eval-after-load "sendmail"
      '(define-key mail-mode-map (kbd "TAB") 'enz-eudc-expand-inline))
    (eval-after-load "post"
      '(define-key post-mode-map (kbd "TAB") 'enz-eudc-expand-inline)))
#+END_SRC

** Filter atom feeds

#+BEGIN_SRC emacs-lisp
(require 'mm-url)
(defadvice mm-url-insert (after DE-convert-atom-to-rss () )
  "Converts atom to RSS by calling xsltproc."
  (when (re-search-forward "xmlns=\"http://www.w3.org/.*/Atom\""
               nil t)
    (message "Converting Atom to RSS... ")
    (goto-char (point-min))
    (call-process-region (point-min) (point-max)
             "xsltproc"
             t t nil
             (expand-file-name "~/atom2rss.xsl") "-")
    (goto-char (point-min))
    (message "Converting Atom to RSS... done")))

(ad-activate 'mm-url-insert)
#+END_SRC

** Reload gnus 

Force unload gnus (all files loaded known to me as of 2014-03-23).

#+BEGIN_SRC emacs-lisp
  (defun tom/reloadgnus ()
    "Unload all gnus files known to this function and reload gnus."
    (interactive)
    (let ((gnusfiles 
           (directory-files (expand-file-name "lisp" tom/--gnus-home) nil ".*\.el$" t)))
      (cl-loop for lib in gnusfiles do
               (ignore-errors 
                 (call-interactively
                  (unload-feature (substring-no-properties lib 0 -3)))))
      (tom/gnus)))
#+END_SRC
* org-mode
** Variables
   :PROPERTIES:
   :ID:       d2eb3552-1033-4e26-ad19-f4fb5b92e551
   :END:

*** Basis / Agenda

#+BEGIN_SRC emacs-lisp
     (setq
      org-directory "~/ownCloud/org-mode"
      org-return-follows-link t
      org-src-fontify-natively t
      org-tags-exclude-from-inheritance '("PROJECT")
      org-list-allow-alphabetical nil
      org-agenda-include-inactive-timestamps t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (if (tom/work?)
      (setq org-agenda-files (list org-journal-dir)
            org-agenda-file-regexp "^\[0-9\]+")
    (setq org-agenda-files (quote ("~/ownCloud/org-mode/todos.org"
                                   "~/ownCloud/org-mode/joocom.org"))))
#+END_SRC
*** owncloud
Use ~org-cladav~ to integrate with an owncloud calendar.

#+BEGIN_SRC emacs-lisp
  (defvar tom/--org-caldav-dir (expand-file-name "org-caldav" tom/--src-base))
  (add-to-list 'load-path tom/--org-caldav-dir)
  (require 'org-caldav)

  (defvar tom/--owncloud-base "https://muehlenweg.dyndns-home.com/owncloud/remote.php/")
  (setq
   org-caldav-url  (concat tom/--owncloud-base "caldav/calendars/tom")
   org-caldav-calendar-id "orgmode"
   org-caldav-inbox "~/ownCloud/org-mode/incoming.org"
   org-caldav-files (quote ("~/ownCloud/org-mode/todos.org"  "~/ownCloud/org-mode/joocom.org"))
   org-icalendar-timezone "Europe/Berlin")

#+END_SRC

*** mobileorg for android

#+BEGIN_SRC emacs-lisp
  (setq
   org-mobile-directory (expand-file-name "~/ownCloud/org-mode")
   org-mobile-files (quote (org-agenda-files))
   org-mobile-inbox-for-pull (expand-file-name "~/ownCloud/org-mode/mobileorg.org"))
#+END_SRC

*** Refile

#+BEGIN_SRC emacs-lisp
(setq
    org-refile-targets (quote ((nil :maxlevel . 9)
                               (org-agenda-files :maxlevel . 9)))
    )
#+END_SRC

*** babel

The languages I like to use.

#+BEGIN_SRC emacs-lisp 
  (org-babel-do-load-languages
   'org-babel-load-languages 
   (quote
    ((emacs-lisp . t) (R . t) (sh . t)
     (ditaa . t) (sass . t)
     (lisp . t) (gnuplot . t))))
#+END_SRC 

The =ditaa.jar= location;

#+BEGIN_SRC emacs-lisp
  (setq org-ditaa-jar-path  "~/.emacs.d/elpa/contrib/scripts/ditaa.jar")
#+END_SRC

I really like org-babel to use zsh

#+BEGIN_SRC emacs-lisp
  (setq org-babel-sh-command "zsh")
#+END_SRC

Don't confirm evaluation.
#+BEGIN_SRC emacs-lisp
  (defun tom/ob-confirm-off ()
    "Turn confirmation for babel code block evaluation off."
    (interactive)
    (setq org-confirm-babel-evaluate nil))
  (global-set-key (kbd "C-c c") 'tom/ob-confirm-off)
#+END_SRC
** Tangle hook

Remove code references in code prior to tangling; that way I can use
them anywhere in the code and get nice links/references in the weaved
document, but don't have to hide them in code comments. 

I always use the form ~(ref:label)~ for code references.

#+BEGIN_SRC emacs-lisp
  (defun tr/remove-code-labels ()
    "remove (ref:.*) from all lines"
    (goto-char (point-min))
    (let* (
           (lbl-re "[ \t]*(ref:[a-zA-Z0-9_-]*)"
                   ))
      (while (re-search-forward lbl-re nil t)
        (replace-match "")
        )))
  
  (add-hook 'org-babel-tangle-body-hook
            (λ () (tr/remove-code-labels)))
  
#+END_SRC 

** agenda views
   :PROPERTIES:
   :ID:       ebf5af82-57f0-490c-9496-f118640b25e5
   :END:

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-custom-commands
  '(

  ("P" "Projects"
  ((tags "PROJECT")))

  ("H" "Office and Home Lists"
       ((agenda)
            (tags-todo "OFFICE")
            (tags-todo "HOME")
            (tags-todo "COMPUTER")
            (tags-todo "DVD")
            (tags-todo "READING")))
  ("O" "Office and Home Lists"
       ((agenda)
            (tags-todo "OFFICE")
            ))

  ("D" "Daily Action List"
       (
            (agenda "" ((org-agenda-ndays 1)
                        (org-agenda-sorting-strategy
                         (quote ((agenda time-up priority-down tag-up)
       )))
                        (org-deadline-warning-days 0)
                        ))))
  )
  )
#+END_SRC

** org2blog

Currently not functioning correctly.

#+BEGIN_SRC emacs-lisp
  (require 'netrc)
  (setq blog (netrc-machine (netrc-parse "~/.netrc") "joocomblog" t))
  (setq org2blog/wp-blog-alist '(("joocom"
                                  :url "http://www.joocom.de/blog/xmlrpc.php"
                                  :username (netrc-get blog "login")
                                  :password (netrc-get blog "password")
                                          ; :default-title "Toms Discovery: "
                                          ; :default-categories ("Geeks!", "Software Entwicklung", "Systemadministration")
                                          ; :tags-as-categories nil
                                  )
                                 ))

#+END_SRC 

** minted

Settings to set code in latex documents with syntax highlighting.

#+BEGIN_SRC emacs-lisp
  (setq org-latex-listings 'minted)
  (setq org-latex-custom-lang-environments
        '(
          (emacs-lisp "common-lispcode")
          (lisp "common-lispcode")
          (R "rcode")
          ))
  (setq org-latex-minted-options
        '(("frame" "lines")
          ("fontsize" "\\scriptsize")
          ))
  (setq org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode  -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode  -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode  -output-directory %o %f"))
#+END_SRC

** =org-macs= 
Why the hell do I do this?
#+BEGIN_SRC emacs-lisp
(require 'org-macs)
#+END_SRC
** Journal
#+BEGIN_SRC emacs-lisp
  (if (not (tom/work?))
      (setq org-journal-dir (expand-file-name "~/ownCloud/org-mode/journal/"))
    (setq org-journal-dir (expand-file-name "~/Documents/journal/")))
#+END_SRC
* Chat and instant messaging 

I used to use =erc=, but I'm giving circe a try -- it just turned 1.5
today :-).

** =circe= Options

Reduce the 'leaving/enter' messages.

#+BEGIN_SRC emacs-lisp
  (setq circe-reduce-lurker-spam t)
#+END_SRC

Enable logging for channels, this is nice for bitlbee conversations.

The manual must be out of date, this doesn't load.

#+BEGIN_SRC emacs-lisp
;  (require 'circe)
;  (require 'lui-autoloads)
;  (enable-lui-logging)
#+END_SRC

** Color the nicknames.

#+BEGIN_SRC emacs-lisp
  (enable-circe-color-nicks)
#+END_SRC

** Don't show the names list at join
#+BEGIN_SRC emacs-lisp
(circe-set-display-handler "353" (lambda (&rest args) nil))
#+END_SRC
** Spellchecking

#+BEGIN_SRC emacs-lisp
  (setq lui-flyspell-p t
        lui-flyspell-alist '((".*" "american")))
#+END_SRC

** Server 
#+BEGIN_SRC emacs-lisp
  (defun tom/set-circe-options ()
    "Set the networks options dynamically just before connection,
  after loading the passwords"
    (let ((--freenode (netrc-machine (netrc-parse "~/.netrc") "freenode" t))
          (--bitlbee  (netrc-machine (netrc-parse "~/.netrc") "bitlbee" t)))
      (setq circe-network-options
            (list
             (list "ZNC"
                   :user (netrc-get --freenode "login")
                   :host "muehlenweg.dyndns-home.com"
                   :pass (netrc-get --freenode "password")
                   )
             (list "Bitlbee"
                   :nick (netrc-get --bitlbee "login")
                   :nickserv-password (netrc-get --bitlbee "password"))))))
#+END_SRC
   
** Smart connect

Straight out of the =circe= wiki

#+BEGIN_SRC emacs-lisp
  (defun circe-network-connected-p (network)
    "Return non-nil if there's any Circe server-buffer whose
  `circe-server-netwok' is NETWORK."
    (catch 'return
      (dolist (buffer (circe-server-buffers))
        (with-current-buffer buffer
          (if (string= network circe-server-network)
              (throw 'return t))))))
  
  (defun circe-maybe-connect (network)
    "Connect to NETWORK, but ask user for confirmation if it's
  already been connected to."
    (interactive "sNetwork: ")
    (if (or (not (circe-network-connected-p network))
            (y-or-n-p (format "Already connected to %s, reconnect?" network)))
        (circe network)))
  (defun irc ()
    "Connect to all configured IRC servers"
    (interactive)
    (tom/set-circe-options)
    (circe-maybe-connect "ZNC")
    (if (not (tom/work?)) (circe-maybe-connect "Bitlbee")))
#+END_SRC

** Desktop notifications

Notify me when tracked buffers have activity -- but not more than one
notification in a given time intervall.

In my emacs setup I have to patch notifications.el --
notifications-close-notification expects an uint32 but gets a int32.

#+BEGIN_SRC emacs-lisp
    (require 'notifications)
    (require 's)
    
    (defvar tom/chatnotification nil
      "ID of the last send desktop notification.")
    (defvar tom/lastchatnotification 0
      "Time of the last send notification, seconds since epoch as float")
    (defvar tom/lastbufferlist nil
      "The value of tracking-buffers when we last notified")
    (defvar tom/chatnotifyintervall 90
      "Minimum delay between chat activity notifications in seconds")
    (defun tom/tracking-buffer-notifications ()
      ""
      (let ((current-t (float-time))
            (current-bl (s-join "\n" tracking-buffers)))
        ;; min tom/chatnotifyintervall seconds since last delay?
        (if (and (not (eql current-bl "")) (not (eql current-bl tom/lastbufferlist))
                 (> (- current-t tom/lastchatnotification) tom/chatnotifyintervall))
            (progn
              ;; delete alst notification id any
              (and tom/chatnotification (notifications-close-notification tom/chatnotification))
              ;; remember time and notify
              (setq  tom/lastchatnotification current-t
                     tom/lastbufferlist current-bl
                     tom/chatnotification (notifications-notify 
                                           :title "Active Buffers"
                                           :body (tom/replace-html-chars current-bl)
                                           :timeout 1500
                                           :desktop-entry "emacs24"
                                           :sound-name "message-new-entry"
                                           :transient))))))
    (defadvice tracking-add-buffer (after tracking-desktop-notify activate)
      (tom/tracking-buffer-notifications))
#+END_SRC
* Behaviour
** File encoding

Everything should be in utf-8. 

#+BEGIN_SRC emacs-lisp
  (prefer-coding-system 'utf-8)
#+END_SRC

** =ibuffer= as buffer screen
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC
** vi-like paren-jump
   :PROPERTIES:
   :ID:       1fada2eb-6533-42da-9c90-63042b99cbc1
   :END:
Use % to jump to corresponding parens

#+BEGIN_SRC emacs-lisp
  (defun goto-match-paren (arg)
    "Go to the matching parenthesis if on parenthesis, otherwise insert
  the character typed."
    (interactive "p")
    (cond ((looking-at "\\s\(") (forward-list 1) (backward-char 1))
      ((looking-at "\\s\)") (forward-char 1) (backward-list 1))
      (t                    (self-insert-command (or arg 1))) ))
  (global-set-key "%" `goto-match-paren)
#+END_SRC

** indentation

Indent using spaces, 2 spaces for each indentation step.

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2)
(setq-default indent-tabs-mode nil)
(setq-default c-basic-offset 2)
#+END_SRC

Indent autimatically as aggressive as possible:

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'aggressive-indent-mode)
#+END_SRC
** Flyspell: Change dictionary 

#+BEGIN_SRC emacs-lisp
  (defun fd-switch-dictionary()
    (interactive)
    (let* ((dic ispell-current-dictionary)
           (change (if (string= dic "deutsch8") "english" "deutsch8")))
      (ispell-change-dictionary change)
      (message "Dictionary switched from %s to %s" dic change)
      ))
  
  (global-set-key (kbd "<f8>")   'fd-switch-dictionary)
#+END_SRC 

** Multiple Cursors

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
  (global-set-key (kbd "C-c M-.") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-c M-,") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c M-a") 'mc/mark-all-like-this)
#+END_SRC

*** Multicursor mark region

After using expand-region the point remains at the start of the
region. Switch point and mark and call multi-cursor.

#+BEGIN_SRC emacs-lisp
  (defun tom/mcdwim ()
    ""
    (interactive)
    (progn
      (exchange-point-and-mark)
      (mc/mark-all-dwim nil)))
  (global-set-key (kbd "\C-c r") 'tom/mcdwim)
#+END_SRC

** Expand region

Context/Language aware region expansion/contraction.

#+BEGIN_SRC emacs-lisp
  (require 'expand-region)
  (global-set-key (kbd "C-=") 'er/expand-region)
#+END_SRC

** Ace jump

#+BEGIN_SRC emacs-lisp
  (autoload
    'ace-jump-mode
    "ace-jump-mode"
    "Emacs quick move minor mode"
    t)
  (define-key global-map (kbd "C-c SPC") 'ace-jump-mode)
#+END_SRC

** REPL toggle

#+BEGIN_SRC emacs-lisp
  (setq rtog/fullscreen t)
  (require 'repl-toggle)
  (setq rtog/mode-repl-alist '(
                               (php-mode . php-boris) 
                               (emacs-lisp-mode . ielm)
                               (elixir-mode . elixir-mode-iex)
                               (ruby-mode . inf-ruby)
                               (js2-mode . nodejs-repl)))
  ;;(rtog/add-repl 'octave-mode (rtog/switch-to-shell-buffer 'inferior-octave-buffer 'inferior-octave))
#+END_SRC

** Opening URLs

Send them to firefox, with keysnail much better then anything else.

#+BEGIN_SRC emacs-lisp
  (setq
   browse-url-browser-function (quote browse-url-firefox))
#+END_SRC

** Speedbar
*** Automatic update

I like speedbar to update automaticly, to always reflect the current state of affairs.

#+BEGIN_SRC emacs-lisp
  (require 'sr-speedbar)
  (sr-speedbar-refresh-turn-on)
#+END_SRC

*** Toggle key

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "H-N") 'sr-speedbar-toggle)
#+END_SRC

** Scrolling

Scroll as much as other programs do, one line at a time and with
enough context around point visible.

#+BEGIN_SRC emacs-lisp
(require 'smooth-scrolling)
#+END_SRC

** Insert current date

Use the 'calendar' to get and format the date.

#+BEGIN_SRC emacs-lisp
  (require 'calendar)

  (defun tom/insert-current-date (&optional omit-day-of-week-p)
    "Insert today's date using the current locale.
      With a prefix argument, the date is inserted without the day of
      the week."
    (interactive "P*")
    (insert (calendar-date-string (calendar-current-date) nil
                                  omit-day-of-week-p)))
  (global-set-key (kbd "\C-c d") 'tom/insert-current-date)
#+END_SRC
** Window movement

*** Goto neighbouring windows
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-<left>") 'window-jump-left)
  (global-set-key (kbd "C-<right>") 'window-jump-right)
  (global-set-key (kbd "C-<down>") 'window-jump-down)
  (global-set-key (kbd "C-<up>") 'window-jump-up)
#+END_SRC
*** Window Layouts / Rotation

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "H-r") 'rotate-window)
  (global-set-key (kbd "H-L") 'rotate-layout)
#+END_SRC

** EDiff

Sensible setup found at 'or emacs('.

#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-diff-options "-w")
  (defun tom/ediff-hook ()
    (ediff-setup-keymap)
    (define-key ediff-mode-map "j" 'ediff-next-difference)
    (define-key ediff-mode-map "k" 'ediff-previous-difference))

  (add-hook 'ediff-mode-hook 'tom/ediff-hook)

#+END_SRC
* Slime

#+BEGIN_SRC emacs-lisp
  ;;;(load (expand-file-name "~/quicklisp/slime-helper.el"))
  ;; Replace "sbcl" with the path to your implementation
  (setq inferior-lisp-program "sbcl")
#+END_SRC

* Version control
** Magit 
#+BEGIN_SRC emacs-lisp
  (require 'magit)
#+END_SRC
   
*** Key bindings
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f7>") 'magit-status)
#+END_SRC

*** Fullscreen

#+BEGIN_SRC emacs-lisp
(fullframe magit-status magit-mode-quit-window nil) 
#+END_SRC

* Services
** =ssh= tunnel

Manage ssh tunnel via prodigy.

#+BEGIN_SRC emacs-lisp
(require 'prodigy)
#+END_SRC
*** Helper functions

**** Build the argument list

#+BEGIN_SRC emacs-lisp
  (defun tom/build-tunnel-args (args)
    "Assemble the ssh tunnel argument list."
    `("-v" ;; allows us to parse for the ready message
      "-N" ;; don't start an interactive shell remotely
      "-L" ,(concat (getf args :localport) ;; the tunnel spec
                    ":"
                    (getf args :tunnel-ip)
                    ":"
                    (getf args :tunnel-port))
      "-l" ,(getf args :user) ;; the username
      "-p" ,(getf args :port) ;; the remote port
      ,(getf args :host)))    ;; the remote host
#+END_SRC

*** Tunnel tag

#+BEGIN_SRC emacs-lisp
  (prodigy-define-tag
    :name 'ssh-tunnel
    :command "ssh"
    :cwd (getenv "HOME")
    :args (prodigy-callback (service)
            (tom/build-tunnel-args
             (getf service :tunnel)))
    :ready-message "debug1: Entering interactive session.")
#+END_SRC

*** Tunnel services

Tunnel definitions are held outside this config to protect the innocent...

#+BEGIN_SRC emacs-lisp
(load-file "~/ownCloud/dotfiles/prodigy.el")
#+END_SRC
** Work Services
#+BEGIN_SRC emacs-lisp
  (when (tom/work?)
    (load-file "~/ownCloud/dotfiles/workservices.el"))
#+END_SRC
* Paste services
** ix.io

#+BEGIN_SRC emacs-lisp
  (let ((ix-io (netrc-machine (netrc-parse "~/.netrc") "ix-io")))
    (setq ix-user (netrc-get ix-io "login"))
    (setq ix-token (netrc-get ix-io "password")))
#+END_SRC

** yagist

#+BEGIN_SRC emacs-lisp
  (let ((github (netrc-machine (netrc-parse "~/.netrc") "yagist")))
    (setq yagist-github-token (netrc-get github "password")))
#+END_SRC

* Server

Always have an emacs server running.

#+BEGIN_SRC emacs-lisp
(require 'server)
(unless (server-running-p)
  (server-start))
#+END_SRC

