* Emacs rocks

This file contains my configurations and adaptations to
my now graphene based setup.

** Lambda

Lambda as λ

#+BEGIN_SRC emacs-lisp
  (defmacro λ (&rest body)
    `(lambda ()
       (interactive)
       ,@body))

  (global-set-key (kbd "H-l") (λ (insert "\u03bb")))
#+END_SRC

* Initial Setup
** Packages

 Package management and loading of utility packages.

*** Management

 Cask manages the packages installed.

 #+BEGIN_SRC emacs-lisp
   (require 'cask "~/.cask/cask.el")
   (cask-initialize)
 #+END_SRC

**** Pallet

 Using =pallet= allows to use Cask and =M-x list-packages= together --
 manual operations performed using =packages.el= are reflected in the
 Cask file.

 #+BEGIN_SRC emacs-lisp
 (require 'pallet)
 (pallet-mode t)
 #+END_SRC

**** Code Loading

 Recompile elisp code on load or require.

 Since auto-compile is installed via cask, we cannot require it before
 package Management is setup.

 #+BEGIN_SRC emacs-lisp
   (setq load-prefer-newer t)
   (require 'auto-compile)
   (auto-compile-on-load-mode 1)
 #+END_SRC

**** Paradox

 Github integration.

 #+BEGIN_SRC emacs-lisp
   (require 'netrc)

   (let ((github-paradox (netrc-machine (netrc-parse "~/.netrc") "paradox")))
     (setq paradox-github-token (netrc-get github-paradox "password")))
 #+END_SRC
** Home <-> Work

 Some things have to be configured differently depending on where I am -- at home or at work.

 #+BEGIN_SRC emacs-lisp
   (defun tom/work? ()
     "Returns `T` if the current machine is at work, `NIL` otherwise"
     (file-exists-p (expand-file-name "~/.work")))
 #+END_SRC

** Emacs =custom=

 #+BEGIN_SRC emacs-lisp
   (setq custom-file "~/.emacs.d/custom.el")
   (load custom-file)
 #+END_SRC

** Hook helper
#+BEGIN_SRC emacs-lisp
  (require 'hook-helpers)
#+END_SRC
** Helper functions
*** Escape HTML entities

 Basics found on ergoemacs.org.

 #+BEGIN_SRC emacs-lisp
   (defun tom/replace-html-chars (text)
     "Replace “<” to “&lt;” and other chars in TEXT."
     (save-restriction      
       (with-temp-buffer
         (insert text)
         (goto-char (point-min))
         (while (search-forward "&" nil t) (replace-match "&amp;" nil t))
         (goto-char (point-min))
         (while (search-forward "<" nil t) (replace-match "&lt;" nil t))
         (goto-char (point-min))
         (while (search-forward ">" nil t) (replace-match "&gt;" nil t))
         (buffer-string))))
 #+END_SRC

* Graphene

Stuff looted from graphene.
** helper functions
#+BEGIN_SRC emacs-lisp
  (defun kill-default-buffer ()
    "Kill the currently active buffer -- set to C-x k so that users are not asked which buffer they want to kill."
    (interactive)
    (let (kill-buffer-query-functions) (kill-buffer)))

  (defun kill-buffer-if-file (buf)
    "Kill a buffer only if it is file-based."
    (when (buffer-file-name buf)
      (when (buffer-modified-p buf)
          (when (y-or-n-p (format "Buffer %s is modified - save it?" (buffer-name buf)))
              (save-some-buffers nil buf)))
      (set-buffer-modified-p nil)
      (kill-buffer buf)))

  (defun kill-all-buffers ()
      "Kill all file-based buffers."
      (interactive)
      (mapc (lambda (buf) (kill-buffer-if-file buf))
       (buffer-list)))

  (defun kill-buffer-and-window ()
    "Close the current window and kill the buffer it's visiting."
    (interactive)
    (progn
      (kill-buffer)
      (delete-window)))

  (defun create-new-buffer ()
    "Create a new buffer named *new*[num]."
    (interactive)
    (switch-to-buffer (generate-new-buffer-name "*new*")))

  (defun insert-semicolon-at-end-of-line ()
    "Add a closing semicolon from anywhere in the line."
    (interactive)
    (save-excursion
      (end-of-line)
      (insert ";")))

  (defun tom/comment-line-dwim (n)
    "Comment or uncomment current line and leave point after
  it. With positive prefix, apply to N lines including current
  one. With negative prefix, apply to -N lines above."
    (interactive "p")
    (comment-or-uncomment-region
     (line-beginning-position)
     (goto-char (line-end-position n)))
    (forward-line 1) (back-to-indentation))

  (defun comment-current-line-dwim ()
    "Comment or uncomment the current line."
    (interactive)
    (save-excursion
      (push-mark (beginning-of-line) t t)
      (end-of-line)
      (comment-dwim nil)))

  (defun newline-anywhere ()
    "Add a newline from anywhere in the line."
    (interactive)
    (end-of-line)
    (newline-and-indent))

  (defun increase-window-height (&optional arg)
    "Make the window taller by one line. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window arg))

  (defun decrease-window-height (&optional arg)
    "Make the window shorter by one line. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window (- 0 arg)))

  (defun decrease-window-width (&optional arg)
    "Make the window narrower by one column. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window (- 0 arg) t))

  (defun increase-window-width (&optional arg)
    "Make the window wider by one column. Useful when bound to a repeatable key combination."
    (interactive "p")
    (enlarge-window arg t))

  ;; Create a new instance of emacs
  (when window-system
    (defun new-emacs-instance ()
      (interactive)
      (let ((path-to-emacs
             (locate-file invocation-name
                          (list invocation-directory) exec-suffixes)))
        (call-process path-to-emacs nil 0 nil))))

#+END_SRC
** editing

#+BEGIN_SRC emacs-lisp
  ;;(delete-selection-mode t)
  (global-visual-line-mode t)
  (setq nlinum-format "%4d")
  (setq default-tab-width 2)
  (setq-default tab-width 2)
  (setq-default indent-tabs-mode nil)
  (prefer-coding-system 'utf-8)
  (set-language-environment 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)

  (show-paren-mode t)
  (setq blink-matching-paren t)
  (electric-pair-mode t)

  (require 'flycheck)
  (flycheck-mode)

  (push '("\\.json\\'" . json-mode) auto-mode-alist)

  ;; don't compile sass/scss on saving
  (setq scss-compile-at-save nil)

  ;; 2-space indent for CSS
  (setq css-indent-offset 2)

  ;; Default Ruby filetypes
  (dolist (regex
           '("\\.watchr$" "\\.arb$" "\\.rake$" "\\.gemspec$" "\\.ru$" "Rakefile$" "Gemfile$" "Capfile$" "Guardfile$" "Rakefile$" "Cheffile$" "Vagrantfile$"))
    (add-to-list 'auto-mode-alist `(,regex . ruby-mode)))

  ;; Remap newline to newline-and-indent in ruby-mode
  (define-hook-helper ruby-mode ()
    (define-key (current-local-map) [remap newline] 'reindent-then-newline-and-indent))

#+END_SRC
** env
#+BEGIN_SRC emacs-lisp
  (require 'smex)
  (require 'flx-ido)
  (smex-initialize)

  (setq inhibit-startup-message t
        color-theme-is-global t
        uniquify-buffer-name-style 'forward
        backup-directory-alist `((".*" . ,temporary-file-directory))
        auto-save-file-name-transforms `((".*" ,temporary-file-directory t))
        ido-mode 1
        flx-ido-mode 1
        ido-enable-flex-matching t
        ido-auto-merge-work-directories-length nil
        ido-create-new-buffer 'always
        ido-use-filename-at-point 'guess
        ido-everywhere t
        ido-use-faces t)
  (require 'ido-completing-read+)
  (ido-ubiquitous-mode 1)

  (fset 'yes-or-no-p 'y-or-n-p)

  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)

  (global-auto-revert-mode t)

  (ido-mode 1)
  (ido-vertical-mode 1)
  (put 'ido-complete 'disabled nil)
  (put 'ido-exit-minibuffer 'disabled nil)
  (put 'autopair-newline 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
#+END_SRC
** keys
#+BEGIN_SRC emacs-lisp

(global-set-key (kbd "C-x k")
                'kill-default-buffer)
(global-set-key (kbd "C-x C-k")
                'kill-buffer-and-window)
(global-set-key (kbd "C-c n")
                'create-new-buffer)
(global-set-key (kbd "C-c N")
                'new-emacs-instance)
(global-set-key (kbd "C-;")
                'insert-semicolon-at-end-of-line)
(global-set-key (kbd "C-<return>")
                'newline-anywhere)
(global-set-key (kbd "M-C-;")
                'tom/comment-line-dwim)
(global-set-key (kbd "C->")
                'increase-window-height)
(global-set-key (kbd "C-<")
                'decrease-window-height)
(global-set-key (kbd "C-,")
                'decrease-window-width)
(global-set-key (kbd "C-.")
                'increase-window-width)
(global-set-key (kbd "M-x")
                'smex)
(global-set-key (kbd "M-X")
                'smex-major-mode-commands)
(global-set-key (kbd "C-c s")
                'sr-speedbar-select-window)

#+END_SRC
** look
#+BEGIN_SRC emacs-lisp
  ;; Work around Emacs frame sizing bug when line-spacing
  ;; is non-zero, which impacts e.g. grizzl.
  (define-hook-helper minibuffer-setup ()
    (set (make-local-variable 'line-spacing) 0)
    (local-set-key (kbd "C-n") 'ido-next-match)
    (local-set-key (kbd "C-p") 'ido-prev-match)
    (setq resize-mini-windows (featurep 'ido-vertical-mode)))
  (setq redisplay-dont-pause t)
#+END_SRC
* Global stuff
** Single frame execution
#+BEGIN_SRC emacs-lisp
  (require 'fullframe)
#+END_SRC



** Key bindings
   :PROPERTIES:
   :ID:       b186cad4-7355-4c52-a1a2-21f52a49aa5f
   :END:
 - Meta-Pause will delete the current frame
 - use f2 as tool-bar toggle (analog to f1 for menu-bar-mode)
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-<pause>") 'delete-frame)
  (global-set-key (kbd "<f1>") 'menu-bar-mode)
  (global-set-key (kbd "<f2>") 'tool-bar-mode)
  (global-set-key (kbd "<f5>") 'flyspell-mode)
  (global-set-key (kbd "<f6>") 'flyspell-prog-mode)
  (global-set-key (kbd "<f9>") 'flymake-mode)
#+END_SRC

*** Window switching/handling
#+BEGIN_SRC emacs-lisp
  (global-set-key
   (kbd "H-o")
   (defhydra hydra-window (:color amaranth)
     "window"
     ("h" windmove-left)
     ("j" windmove-down)
     ("k" windmove-up)
     ("l" windmove-right)
     ("V" (lambda ()
            (interactive)
            (split-window-right)
            (windmove-right))
      "vert")
     ("X" (lambda ()
            (interactive)
            (split-window-below)
            (windmove-down))
      "horz")
     (">" enlarge-window-horizontally)
     ("<" shrink-window-horizontally)
     ("v" shrink-window)
     ("^" enlarge-window)
     ("t" transpose-frame "'")
     ("o" delete-other-windows "one" :color blue)
     ("a" ace-window "ace")
     ("s" ace-swap-window "swap")
     ("d" ace-delete-window "del")
     ("i" ace-maximize-window "ace-one" :color blue)
     ("b" ido-switch-buffer "buf")
     ("m" headlong-bookmark-jump "bmk")
     ("q" nil "cancel")))
#+END_SRC 
*** launcher map 

Launch seldom used emacs tools via C-x l <KEY>.

Inspired/copied from endless parentheses blog

#+BEGIN_SRC emacs-lisp
  (global-set-key
   (kbd "H-L")
   (defhydra hydra-launch (:color blue :timeout 3)
     "launch"
     ("c" calc "calc")
     ("g" git-timemachine "git timemachine")
     ("d" ediff-buffers "ediff")
     ("f" find-dired "find")
     ("r" tom/projectile-ranger)
     ("G" rgrep "grep")
     ("h" man "man")
     ("p" paradox-list-packages "packages")
     ("s" tom/eshell "shell")
     ("t" proced "proced")
     ))

#+END_SRC

*** hjkl-navigation
#+BEGIN_SRC emacs-lisp
  (global-set-key
   (kbd "H-V")
   (defhydra hydra-vim-navi (:color red)
     "navigate"
     ("h" backward-char "left")
     ("j" next-line "down")
     ("k" previous-line "up")
     ("l" forward-char "right")))
#+END_SRC
*** Toggle states

#+BEGIN_SRC emacs-lisp
  (global-set-key
   (kbd "H-t")
   (defhydra hydra-toggle (:color red :timeout 3)
     "toggle"
     ("c" column-number-mode "col-nums")
     ("d" toggle-debug-on-error "debug on error")
     ("f" auto-fill-mode "auto fill")
     ("l" display-line-numbers-mode "show line numbers")
     ("L" toggle-truncate-lines "truncate lines")
     ("g" golden-ratio-mode "1.61803")
     ("q" toggle-debug-on-quit "debug on quit")
     ("n" narrow-or-widen-dwim "narrow")
     ("b" tom/ob-confirm-toggle "babel confirmation")))

#+END_SRC

**** Narrowing

#+BEGIN_SRC emacs-lisp
  (setq narrow-to-defun-include-comments t)
  (defun narrow-or-widen-dwim (p)
    "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
  Intelligently means: region, org-src-block, org-subtree, or defun,
  whichever applies first.
  Narrowing to org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer is already
  narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing command.
           ;; Remove this first conditional if you don't want it.
           (cond ((org-in-src-block-p)
                  (org-edit-src-code)
                  (delete-other-windows))
                 ((org-at-block-p)
                  (org-narrow-to-block))
                 (t (org-narrow-to-subtree))))
          (t (narrow-to-defun))))
#+END_SRC

*** Rectangle
#+BEGIN_SRC emacs-lisp
  (defun tom/rec-ex-point-mark ()
    (interactive)
    (if rectangle-mark-mode
        (exchange-point-and-mark)
      (let ((mk (mark)))
        (rectangle-mark-mode 1)
        (goto-char mk))))

  (global-set-key
   (kbd "H-C-r")
   (defhydra hydra-rectangle (:color amaranth
                              :body-pre (rectangle-mark-mode 1)
                              :post (deactivate-mark))
     "
    ^_k_^     _d_elete    _s_tring
  _h_   _l_   _o_k        _y_ank
    ^_j_^     _n_ew-copy  _r_eset
  ^^^^        _e_xchange  _u_ndo
  ^^^^        ^ ^         _p_aste
  "
     ("h" backward-char nil)
     ("l" forward-char nil)
     ("k" previous-line nil)
     ("j" next-line nil)
     ("e" tom/rec-ex-point-mark nil)
     ("n" copy-rectangle-as-kill nil)
     ("d" delete-rectangle nil)
     ("r" (if (region-active-p)
              (deactivate-mark)
            (rectangle-mark-mode 1)) nil)
     ("y" yank-rectangle nil)
     ("u" undo nil)
     ("s" string-rectangle nil)
     ("p" kill-rectangle nil)
     ("o" nil nil)))
#+END_SRC
*** Code Folding
#+BEGIN_SRC emacs-lisp
  (vimish-fold-global-mode 1)
  (global-set-key
   (kbd "H-C-f")
   (defhydra hydra-folding (:color red)
     "
      _o_pen fold   open _a_ll folds    
      _c_lose fold  _r_efold    
      "
     ("o" vimish-fold-unfold)
     ("c" vimish-fold)
     ("a" vimish-fold-unfold-all)
     ("r" vimish-fold-refold)
     ("y" vimish-fold-avy)))
#+END_SRC
** Undo as tree

#+BEGIN_SRC emacs-lisp
  (global-undo-tree-mode)
#+END_SRC
** yasnippet Setup

   A few variables to be used in snippets.
#+BEGIN_SRC emacs-lisp
  (setq fb-author "tregner")
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (require 'yasnippet)
  (require 'warnings)
  (yas-reload-all)
  (add-to-list 'warning-suppress-types '(yasnippet backquote-change))
#+END_SRC
** Sticky window
#+BEGIN_SRC emacs-lisp
  (require 'popwin)
  (popwin-mode 1)
  ;; (pop popwin:special-display-config)
  (push '("*Flycheck error messages*" :height 0.1 :noselect t :position bottom) popwin:special-display-config)
  (push '("\*GEBEN<.*> output\*" :regexp t :position left :width 0.3 :stick t :dedicated t) popwin:special-display-config)
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (defun tom/sticky-window (name)
    "Make the window NAME sticky."
    (let ((curr-win (car (get-buffer-window-list name))))
      (set-window-buffer curr-win (get-buffer name))
      (set-window-dedicated-p curr-win t)))
#+END_SRC

** perspectives
#+BEGIN_SRC emacs-lisp
    (with-eval-after-load "persp-mode"
      (defvar persp-mode-projectile-bridge-before-switch-selected-window-buffer nil)

      (setq persp-add-buffer-on-find-file 'if-not-autopersp)

      (persp-def-auto-persp "projectile"
                            :parameters '((dont-save-to-file . t)
                                          (persp-mode-projectile-bridge . t))
                            :hooks '(projectile-before-switch-project-hook
                                     projectile-after-switch-project-hook
                                     projectile-find-file-hook
                                     find-file-hook)
                            :dyn-env '((after-switch-to-buffer-adv-suspend t))
                            :switch 'frame
                            :predicate
                            #'(lambda (buffer &optional state)
                                (if (eq 'projectile-before-switch-project-hook
                                        (alist-get 'hook state))
                                    state
                                  (and
                                   projectile-mode
                                   (buffer-live-p buffer)
                                   (buffer-file-name buffer)
                                   ;; (not git-commit-mode)
                                   (projectile-project-p)
                                   (or state t))))
                            :get-name
                            #'(lambda (state)
                                (if (eq 'projectile-before-switch-project-hook
                                        (alist-get 'hook state))
                                    state
                                  (push (cons 'persp-name
                                              (concat "p) "
                                                      (with-current-buffer (alist-get 'buffer state)
                                                        (projectile-project-name))))
                                        state)
                                  state))
                            :on-match
                            #'(lambda (state)
                                (let ((hook (alist-get 'hook state))
                                      (persp (alist-get 'persp state))
                                      (buffer (alist-get 'buffer state)))
                                  (case hook
                                    (projectile-before-switch-project-hook
                                     (let ((win (if (minibuffer-window-active-p (selected-window))
                                                    (minibuffer-selected-window)
                                                  (selected-window))))
                                       (when (window-live-p win)
                                         (setq persp-mode-projectile-bridge-before-switch-selected-window-buffer
                                               (window-buffer win)))))

                                    (projectile-after-switch-project-hook
                                     (when (buffer-live-p
                                            persp-mode-projectile-bridge-before-switch-selected-window-buffer)
                                       (let ((win (selected-window)))
                                         (unless (eq (window-buffer win)
                                                     persp-mode-projectile-bridge-before-switch-selected-window-buffer)
                                           (set-window-buffer
                                            win persp-mode-projectile-bridge-before-switch-selected-window-buffer)))))

                                    (find-file-hook
                                     (setcdr (assq :switch state) nil)))
                                  (if (case hook
                                        (projectile-before-switch-project-hook nil)
                                        (projectile-find-file-hook nil)
                                        (find-file-hook nil)
                                        (t t))
                                      (persp--auto-persp-default-on-match state)
                                    (setcdr (assq :after-match state) nil)))
                                state)
                            :after-match
                            #'(lambda (state)
                                (when (eq 'find-file-hook (alist-get 'hook state))
                                  (run-at-time 0.5 nil
                                               #'(lambda (buf persp)
                                                   (when (and (eq persp (get-current-persp))
                                                              (not (eq buf (window-buffer (selected-window)))))
                                                     ;;(switch-to-buffer buf)
                                                     (persp-add-buffer buf persp t nil)))
                                               (alist-get 'buffer state)
                                               (get-current-persp)))
                                (persp--auto-persp-default-after-match state)))

      ;; (add-hook 'persp-after-load-state-functions
      ;;           #'(lambda (&rest args) (persp-auto-persps-pickup-buffers)) t)
      )
    ;; (projectile-mode)
    ;; (persp-mode-projectile-bridge-mode 1)
    (require 'persp-mode)
    (persp-mode)
  (defun tom/switch-project ()
    "Switch to a projectile project; activate 'non' perspective first"
    (interactive)
    (persp-switch "none")
    (call-interactively 'projectile-switch-project))
  (defmacro with-perspective (name &rest body)
    "Switch to the perspective given by NAME while evaluating BODY."
    (declare (indent 1))
    (let ((old (cl-gensym)))
      `(progn
         (let ((,old (when (get-current-persp) (persp-name (get-current-persp))))
               (last-persp-cache persp-last-persp-name))
           (unwind-protect
               (progn
                 (persp-switch ,name)
                 ,@body)
             (when ,old (persp-switch ,old)))
           (setq persp-last-persp-name last-persp-cache)))))

  (global-set-key (kbd "H-P")
                  (defhydra hydra-persp (:color red :timeout 3)
                    "Perspective"
                    ("d" tom/switch-project "Switch dired")
                    ("s" (call-interactively 'persp-switch) "Switch/Create")
                    ("m" (call-interactively 'persp-set-buffer) "Move buffer")
                    ("n" persp-next "Next Perspective")
                    ("p" persp-prev "Previous Perspective")
                    ("i" projectile-invalidate-cache "Invalidate file cache")
                    ("q" nil "Quit")))



#+END_SRC
** Tramp Setup
#+BEGIN_SRC emacs-lisp
  (setq tramp-shell-prompt-pattern "\\(?:^\\| \\)[^]#$%>❯\n]*#?[]#$%>❯] *\\(\\[[0-9;]*[a-zA-Z] *\\)*")
#+END_SRC
* GPG setup

GPG is handled almost transparently in emacs nowadays; this setup
helps for remote sessions.

<wgreenhouse> tomterl: this assumes emacsclient/emacs --daemon are      [15:35]
    invoked from a shell that is properly setting GPG_AGENT_INFO
    already
<wgreenhouse> but according to documentation, GPG_TTY needs to be
    adjusted for each terminal
> wgreenhouse: thanks -- should be the case, I'll make a note
<taylanub> "arc4random_uniform(9000) + 1000" should give me a good      [15:36]
    4-digit random number, right ?
<wgreenhouse> tomterl: also, I really don't like it because it will     [15:38]
    screw up DISPLAY for any jobs started from the gui emacsclient
    when I am back at that machine
> wgreenhouse: Yepp - we see, when I have the time to tackle gpg,       [15:39]
    maybe I find a cleaner solution
<baboon`> how can I call several functions over a single selection
    without re-selecting between each


(defun tom/kludge-gpg-agent (frame)
  (unless (display-graphic-p)
    (setenv "DISPLAY" nil)
    (setenv "GPG_TTY" (terminal-name frame))))

(add-hook 'after-make-frame-functions 'wg/kludge-gpg-agent)

* Emacs shell

I use =vim= and =htop=, so let's add those to =eshell-visual-commands=. 

#+BEGIN_SRC emacs-lisp
  (require 'eshell)
  (require 'em-term)
  (require 'em-smart)
  (setq eshell-where-to-jump 'begin)
  (setq eshell-review-quick-commands nil)
  (setq eshell-smart-space-goes-to-end t)

  (add-to-list 'eshell-visual-commands "htop")
  (add-to-list 'eshell-visual-commands "vim")
  (add-hook 'eshell-mode-hook 'eshell-smart-initialize)
  (setq eshell-prompt-regexp "^[^#$]*[#$] ")
  (defvar tom/shellframe nil)
  (add-to-list 'frame-inherited-parameters 'alpha)
  (defun tom/eshell ()
    "Start or switch to an eshell specific to the current
        projectile project, or the global '*eshell*' if not in a
        project"
    (interactive)
    (let ((pers (get-current-persp))
          (proj (if (projectile-project-p) (projectile-project-root))))
      (unless
          (and tom/shellframe (framep tom/shellframe) (frame-live-p tom/shellframe))
        (setq tom/shellframe (make-frame)))
      (select-frame tom/shellframe)
      (raise-frame)
      (if proj
          (let* ((-project (projectile-default-project-name proj))
                 (eshell-buffer-name (concat "* " -project " eshell *")))
            (if pers (persp-switch (persp-name pers)))
            (cd proj)
            (if (buffer-live-p (get-buffer eshell-buffer-name))
                (switch-to-buffer eshell-buffer-name)
              (eshell)))
        (eshell))))
  (defun tom/short-path (p-lst &optional len)
    (let ((len (or len 3))
          (path (if (listp p-lst) p-lst (split-string p-lst "/"))))
      (if (> (length path) len)
          (concat
           (mapconcat (lambda (elm) (if (zerop (length elm)) ""
                                      (substring elm 0 1)))
                      (butlast path len)
                      "/")
           "/"
           (mapconcat (lambda (elm) elm)
                      (last path len)
                      "/"))
        (mapconcat (lambda (elm) elm)
                   path
                   "/"))))

#+END_SRC

** ~eshell~ prompt
#+BEGIN_SRC emacs-lisp
  (defun eshell/ef (fname-regexp &rest dir) (ef fname-regexp default-directory))

  ;;; ---- path manipulation

  (defun pwd-repl-home (pwd)
    (interactive)
    (let* ((home (expand-file-name (getenv "HOME")))
           (home-len (length home)))
      (if (and
           (>= (length pwd) home-len)
           (equal home (substring pwd 0 home-len)))
          (concat "~" (substring pwd home-len))
        pwd)))

  (defun curr-dir-git-branch-string (pwd)
    "Returns current git branch as a string, or the empty string if
  PWD is not in a git repo (or the git command is not found)."
    (interactive)
    (when (and (eshell-search-path "git")
               (locate-dominating-file pwd ".git"))
      (let ((git-output (shell-command-to-string (concat "cd " pwd " && git branch | grep '\\*' | sed -e 's/^\\* //'"))))
        (propertize (concat "["
                (if (> (length git-output) 0)
                    (substring git-output 0 -1)
                  "(no branch)")
                "]") 'face `(:foreground "darkgreen"))
        )))

  (setq eshell-prompt-function
        (lambda ()
          (concat
           (propertize
            (tom/short-path (pwd-repl-home (eshell/pwd)))
            'face `(:foreground "darkorange"))
           (or (curr-dir-git-branch-string (eshell/pwd)))
           (propertize "$ " 'face 'default))))

  (setq eshell-highlight-prompt nil)
#+END_SRC
* Completion

I use ~company-mode~ as completion system. For most languages I use
the newer GNU global -- with pygmentize backend -- to provide tags for
code traversal and (additional) completion.

** Configure ~company-mode~

Use ~company-mode~ globally.

I live in a case sensitive world, so don't alter the case of
completions, but provide completions without regard for the case fo
the stuff I entered.

#+BEGIN_SRC emacs-lisp
                                          ;(global-auto-complete-mode -1)
  (require 'company)
  (add-hook 'after-init-hook 'global-company-mode)
  (setq company-dabbrev-downcase nil
        company-dabbrev-ignore-case t)
  (eval-after-load 'company
    '(define-key company-active-map (kbd "C-c h") #'company-quickhelp-manual-begin))
#+END_SRC
*** Key bindings

Fasten seat belts, we enter hyper space...

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "H-SPC") 'company-complete)
#+END_SRC

** company-box
#+BEGIN_SRC emacs-lisp
  (require 'company-box)
  (add-hook 'company-mode-hook 'company-box-mode)
#+END_SRC
** GNU global

#+BEGIN_SRC emacs-lisp
(defun gtags-root-dir ()
    "Returns GTAGS root directory or nil if doesn't exist."
    (with-temp-buffer
      (if (zerop (call-process "global" nil t nil "-pr"))
          (buffer-substring (point-min) (1- (point-max)))
        nil)))

(defun gtags-update ()
    "Make GTAGS incremental update"
    (call-process "global" nil nil nil "-u"))

(defun gtags-root-dir ()
    "Returns GTAGS root directory or nil if doesn't exist."
    (with-temp-buffer
      (if (zerop (call-process "global" nil t nil "-pr"))
          (buffer-substring (point-min) (1- (point-max)))
        nil)))

(defun gtags-update-single(filename)  
      "Update Gtags database for changes in a single file"
      (interactive)
      (start-process "update-gtags" "update-gtags" "bash" "-c" (concat "cd " (gtags-root-dir) " ; gtags --single-update " filename )))

(defun gtags-update-current-file()
      (interactive)
      (defvar filename)
      (setq filename (replace-regexp-in-string (gtags-root-dir) "." (buffer-file-name (current-buffer))))
      (gtags-update-single filename)
      (message "Gtags updated for %s" filename))

(defun gtags-update-hook()
      "Update GTAGS file incrementally upon saving a file"
      (when (and (boundp 'ggtags-mode) ggtags-mode)
        (when (gtags-root-dir)
          (gtags-update-current-file))))

(add-hook 'after-save-hook 'gtags-update-hook)
#+END_SRC
* Projects
** projectile

Use projectile automatically.

#+BEGIN_SRC emacs-lisp
  (define-hook-helper prog-mode ()
    (progn (require 'dash)(projectile-mode 1)))
#+END_SRC 

Ignore .git, and especially those in base/includes which are always to
be treated as part of the project by projectile.

Marking the root of a project are only 

- ~RoboFile.php~ for php-projects
- ~manifest.json~ for node/foxx applications (javascript)
- ~.projectile~ as manually added mark for other project types

#+BEGIN_SRC emacs-lisp
    (require 'projectile)
    (defun tom/projectile-ranger ()
      "Open `ranger' at the root of the project."
      (interactive)
      (golden-ratio-mode -1)
      (ranger (projectile-project-root)))
    (add-to-list 'projectile-globally-ignored-directories ".git")
    (add-to-list 'projectile-globally-ignored-directories "base/.git")
    (add-to-list 'projectile-globally-ignored-directories "includes/.git")
    (add-to-list 'projectile-globally-ignored-directories ".cask")
    (add-to-list 'projectile-project-root-files "RoboFile.php")
    (add-to-list 'projectile-project-root-files "manifest.json")
    (add-to-list 'projectile-project-root-files ".projectile")
    (setq projectile-project-root-files-functions '(projectile-root-top-down))
    (setq projectile-switch-project-action #'projectile-find-file)
    (setq projectile-find-dir-includes-top-level t)
    (setq projectile-indexing-method 'native)
    (setq projectile-enable-caching t)

#+END_SRC
*** Perspectives
#+BEGIN_SRC emacs-lisp
(when (not (fboundp 'make-variable-frame-local))
  (defun make-variable-frame-local (variable) variable))
(persp-mode)
#+END_SRC
*** Keys
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "H-p") 'projectile-commander)

#+END_SRC

* Appearance
** Font

#+BEGIN_SRC emacs-lisp
  (defvar tom/default-font "-ADBE-Source Code Pro-semibold-normal-normal-*-12-*-*-*-m-0-iso10646-1"
    "The font to use under normal circumstances")

  (defvar tom/fallback-font "-Free-Symbola-normal-normal-semicondensed-*-12-*-*-*-*-0-iso10646-1"
    "Font to use, if the default font misses a glyph.")

  (setq default-frame-alist `((font . ,tom/default-font)))

  (set-fontset-font "fontset-default" '(#x10000 . #x1ffff) tom/fallback-font)
#+END_SRC 

*** icons-in-terminal integration
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.local/share/icons-in-terminal/")
  (require 'icons-in-terminal)
  (require 'company-box)
  (setq company-box-icons-unknown 'fa_question_circle)

  (setq company-box-icons-elisp
     '((fa_tag :face font-lock-function-name-face) ;; Function
       (fa_cog :face font-lock-variable-name-face) ;; Variable
       (fa_cube :face font-lock-constant-face) ;; Feature
       (md_color_lens :face font-lock-doc-face))) ;; Face

  (setq company-box-icons-yasnippet 'fa_bookmark)

  (setq company-box-icons-lsp
        '((1 . fa_text_height) ;; Text
          (2 . (fa_tags :face font-lock-function-name-face)) ;; Method
          (3 . (fa_tag :face font-lock-function-name-face)) ;; Function
          (4 . (fa_tag :face font-lock-function-name-face)) ;; Constructor
          (5 . (fa_cog :foreground "#FF9800")) ;; Field
          (6 . (fa_cog :foreground "#FF9800")) ;; Variable
          (7 . (fa_cube :foreground "#7C4DFF")) ;; Class
          (8 . (fa_cube :foreground "#7C4DFF")) ;; Interface
          (9 . (fa_cube :foreground "#7C4DFF")) ;; Module
          (10 . (fa_cog :foreground "#FF9800")) ;; Property
          (11 . md_settings_system_daydream) ;; Unit
          (12 . (fa_cog :foreground "#FF9800")) ;; Value
          (13 . (md_storage :face font-lock-type-face)) ;; Enum
          (14 . (md_closed_caption :foreground "#009688")) ;; Keyword
          (15 . md_closed_caption) ;; Snippet
          (16 . (md_color_lens :face font-lock-doc-face)) ;; Color
          (17 . fa_file_text_o) ;; File
          (18 . md_refresh) ;; Reference
          (19 . fa_folder_open) ;; Folder
          (20 . (md_closed_caption :foreground "#009688")) ;; EnumMember
          (21 . (fa_square :face font-lock-constant-face)) ;; Constant
          (22 . (fa_cube :face font-lock-type-face)) ;; Struct
          (23 . fa_calendar) ;; Event
          (24 . fa_square_o) ;; Operator
          (25 . fa_arrows)) ;; TypeParameter
        )
  (setq company-box-icons-acphp
     '((fa_tasks :face font-lock-function-name-face) ;; Trait
       (fa_cube :face font-lock-function-name-face) ;; Class
       (fa_tags :face font-lock-function-name-face) ;; Method
       (fa_tag :face font-lock-function-name-face) ;; Function
       (fa_plus_square :face font-lock-function-name-face) ;; Property
       (fa_bullseye :face font-lock-function-name-face) ;; Constant
       (fa_cog :face font-lock-function-name-face) ;; Variable
       (fa_cubes :face font-lock-variable-name-face) ;; Interface
       (fa_object_group :face font-lock-constant-face) ;; Namespace
       (fa_stop_circle_o :face font-lock-constant-face) ;; Usetrait
       (md_storage :face font-lock-type-face))) ;; 

  (add-to-list 'company-box-icons-functions 'company-box-icons--acphp)
#+END_SRC
** Fontlock et.al.
   :PROPERTIES:
   :ID:       7edcd500-dcee-4484-9f44-9a65a3f29c71
   :END:

#+BEGIN_SRC emacs-lisp
  (global-font-lock-mode 1)
  (global-hl-line-mode -1)
  (line-number-mode 1)
  (column-number-mode 1)
  (setq mouse-buffer-menu-mode-mult 1)
  (setq ranger-show-literal nil)
#+END_SRC

** Scrollbar
   :PROPERTIES:
   :ID:       88e6ec5b-6aa6-4e18-b25e-7b2756d0918f
   :END:

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'scroll-bar-mode)
    (scroll-bar-mode -1))
#+END_SRC

** Menu and Toolbar

#+BEGIN_SRC emacs-lisp
  (when (fboundp tool-bar-mode)
    (tool-bar-mode -1))
  (when (fboundp menu-bar-mode)
    (menu-bar-mode -1))
#+END_SRC

** Color Theme
   :PROPERTIES:
   :ID:       eb979d64-dc35-4bdd-879c-9a73408096f2
   :END:
#+BEGIN_SRC emacs-lisp
  (load-theme 'kaolin-ocean t)
  (set-face-attribute 'org-level-1 nil :height 1.0)
  (set-face-attribute 'org-level-2 nil :height 1.0)
  (set-face-attribute 'org-level-3 nil :height 1.0)
  (set-face-attribute 'org-scheduled-today nil :height 1.0)
  (set-face-attribute 'org-agenda-date-today nil :height 1.1)
  (set-face-attribute 'org-table nil :foreground "#008787")
#+END_SRC

*** Adapt company-mode
#+BEGIN_SRC emacs-lisp
  (require 'color)

  (let ((bg (face-attribute 'default :background))
        (fg (face-attribute 'default :foreground)))
    (custom-set-faces
     `(company-tooltip ((t (:inherit default :background ,(color-lighten-name bg 20)))))
     `(company-scrollbar-bg ((t (:background ,(color-lighten-name bg 12)))))
     `(company-scrollbar-fg ((t (:background ,(color-lighten-name bg 2)))))
     `(company-tooltip-selection ((t (:inherit default :foreground ,(color-lighten-name bg 12) :background ,(color-lighten-name fg 20)))))
     `(company-tooltip-common ((t (:inherit default :background ,(color-lighten-name bg 12) :foreground ,(color-lighten-name fg 20)))))))
#+END_SRC
** TreeView

*** Show nice(?) icons

#+BEGIN_SRC emacs-lisp
(setq tree-widget-image-enable 1)
#+END_SRC

** Modeline

#+BEGIN_SRC emacs-lisp
  (require 'smart-mode-line)
  (sml/setup)
#+END_SRC

** Colors on terminals

#+BEGIN_SRC emacs-lisp
(require 'color-theme-approximate)
#+END_SRC

** Highlight uncommited changes
Show uncomitted changes in the fringe.
#+BEGIN_SRC emacs-lisp
  (require 'diff-hl)
  (global-diff-hl-mode)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
#+END_SRC
** Whitespace visualization

I find it unnecessary to mark normal spaces, but to visualize tab
characters and newlines is a possible lifesaver.

# +BEGIN_SRC emacs-lisp
  (setq whitespace-display-mappings
        '(
          (newline-mark 10 [8629 10])
          (tab-mark 9 [8677 9] [92 9])
          ))

  (setq whitespace-style '(face tabs newline tab-mark newline-mark))
  (add-hook 'prog-mode-hook 'whitespace-mode)
  (add-hook 'text-mode-hook 'whitespace-mode)
# +END_SRC

** Hide the mode line

This is interesting for presentations (e.g.).

#+BEGIN_SRC emacs-lisp
(defvar-local hidden-mode-line-mode nil)
(defvar-local hide-mode-line nil)

(define-minor-mode hidden-mode-line-mode
  "Minor mode to hide the mode-line in the current buffer."
  :init-value nil
  :global nil
  :variable hidden-mode-line-mode
  :group 'editing-basics
  (if hidden-mode-line-mode
      (setq hide-mode-line mode-line-format
            mode-line-format nil)
    (setq mode-line-format hide-mode-line
          hide-mode-line nil))
  (force-mode-line-update)
  ;; Apparently force-mode-line-update is not always enough to
  ;; redisplay the mode-line
  (redraw-display)
  (when (and (called-interactively-p 'interactive)
             hidden-mode-line-mode)
    (run-with-idle-timer
     0 nil 'message
     (concat "Hidden Mode Line Mode enabled.  "
             "Use M-x hidden-mode-line-mode to make the mode-line appear."))))
#+END_SRC

** Minimap

This is a birds eye view of the current buffer.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "H-M") 'minimap-mode)
  
#+END_SRC

** Fringe
#+BEGIN_SRC emacs-lisp
(fringe-mode (cons 16  8))
#+END_SRC

** Frametitle
#+BEGIN_SRC emacs-lisp
  (setq-default frame-title-format
                '("" (:eval
                      (if (projectile-project-p)
                          (projectile-project-name)
                        invocation-name))
                  ": " (:eval
                        (if (buffer-file-name)
                            (tom/short-path (abbreviate-file-name (buffer-file-name)) 1)
                          "%b"))))
  (define-hook-helper focus-out ()
    (set-frame-parameter (selected-frame)
                         'title (if (projectile-project-p)
                                    (projectile-project-name)
                                  invocation-name)))
  (define-hook-helper focus-in ()
    (set-frame-parameter (selected-frame)
                         'title nil))

#+END_SRC
** Dashboard

#+BEGIN_SRC emacs-lisp
  (setq dashboard-items '((projects . 10)(bookmarks . 10)))
  (dashboard-setup-startup-hook)
#+END_SRC

** coloured parenthesis
#+BEGIN_SRC emacs-lisp
  (require 'rainbow-delimiters)
  (define-hook-helper prog-mode () 
    (rainbow-delimiters-mode 1))
#+END_SRC
* GNUS News and Mail

#+BEGIN_SRC emacs-lisp
  (defun tom/gnus ()
    "Setup and start GNUS"
    (interactive)
    (persp-switch "mail")
    (require 'gnus)
    (require 'gnus-util)
    (require 'smtpmail)
    (require 'nnimap)

    (if (tom/work?)
        (progn
          (setq user-mail-address "thomas.regner@fb-research.de")
          (setq user-full-name "Tom Regner")
          (setq smtpmail-smtp-server "zeta"
                send-mail-function 'smtpmail-send-it)
          (setq message-send-mail-function 'smtpmail-send-it)
          (setq smtpmail-smtp-service 25)
          (setq gnus-message-archive-method
                '(nnimap "franke_bornberg"))
          (setq gnus-message-archive-group
                "Gesendete Objekte"))
      (progn
        (setq user-mail-address "tom@goochesa.de")
        (setq user-full-name "Tom Regner")
        (setq smtpmail-smtp-server "sec.goochesa.de"
              send-mail-function 'smtpmail-send-it)
        (setq message-send-mail-function 'smtpmail-send-it)
        (setq smtpmail-smtp-service 25)))
    (setq
     starttls-use-gnutls t
     starttls-gnutls-program "gnutls-cli"
     starttls-extra-arguments "")
    (setq smtpmail-debug-info t)
    (setq smtpmail-debug-verb t)
    (setq gnus-completing-read-function 'gnus-ido-completing-read)

    ;; display nice arrows in thread-view (summary buffer)
    ;; the font must have the glyphs!
    (setq-default
     gnus-summary-line-format "%U%R%z %(%&user-date;  %-15,15f %* %B%-80,80s%)\n"
     gnus-user-date-format-alist '((t . "%d.%m.%Y %H:%M"))
     gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references
     gnus-thread-sort-functions '(gnus-thread-sort-by-date)
     gnus-sum-thread-tree-false-root ""
     gnus-sum-thread-tree-indent " "
     gnus-sum-thread-tree-leaf-with-other "├► "
     gnus-sum-thread-tree-root ""
     gnus-sum-thread-tree-single-leaf "╰► "
     gnus-sum-thread-tree-vertical "│"
     )

    (setq gnus-select-method
          (if (not (tom/work?))
              '(nnimap "tomsdiner"
                       (nnimap-address "mail.tomsdiner.org")
                       (nnimap-server-port 993)
                       (nnimap-authinfo-file (expand-file-name "~/.authinfo"))
                       (nnimap-stream ssl)
                       )
            '(nnimap "franke_bornberg"
                     (nnimap-address "zeta")
                     (nnimap-server-port 143)
                     (nnimap-authinfo-file (expand-file-name "~/.authinfo"))
                     (nnimap-stream network)
                     (nnimap-inbox "INBOX")
                     (nnmail-expiry-target "nnimap+franke_bornberg:Gelöschte Objekte")
                     (nnmail-expiry-wait 'immediate)
                     )
            ))
    (if (not (tom/work?))
        (setq gnus-secondary-select-methods
              '(
                (nnimap "Goochesa"
                        (nnimap-address "sec.goochesa.de")
                        (nnimap-authinfo-file (expand-file-name "~/.authinfo"))
                        (nnimap-stream tls)
                                          ;                    (nnimap-server-port 993)
                                          ;                    (nnimap-authenticator "plain")
                        )
                )))
    ;; (setq gnus-secondary-select-methods
    ;;       '(
    ;;         ;; (nnimap "Joocom"
    ;;         ;;          (nnimap-address "127.0.0.1")
    ;;         ;;          (nnimap-server-port 20251)
    ;;         ;;          (nnimap-authinfo-file (expand-file-name "~/.authinfo"))
    ;;         ;;          (nnimap-stream ssl)
    ;;         ;;          (nnimap-authenticator "login")
    ;;         ;;          )
    ;;         (nntp "news.t-online.de")
    ;;         )
    ;;       )


    ;; lez gnus-demon check for new news and mail every 5mins, if emacs
    ;; is idle
    (defun gnus-demon-scan-mail-or-news-and-update ()
      "Scan for new mail/news and update the *Group* buffer"
      (when (gnus-alive-p)
        (save-window-excursion
          (save-excursion
            (set-buffer gnus-group-buffer)
            (gnus-group-get-new-news)))))

    (defun gnus-demon-scan-and-update ()
      (gnus-demon-scan-mail-or-news-and-update))

    ;; (gnus-demon-add-handler 'gnus-demon-scan-and-update nil 5)
    ;; (setq gnus-use-demon t)
    ;; (gnus-demon-init)

    ;; (gnus-demon-add-scanmaoupil)
    (gnus)

    (require 'ldap)
    (require 'eudc)

    ;; (setq eudc-default-return-attributes nil
    ;;       eudc-strict-return-matches nil)

    (setq ldap-ldapsearch-args (quote ("-LL" "-tt")))

    (if (tom/work?)
        (progn
          (advice-add #'eudc-ldap-simple-query-internal :filter-args
                      (lambda (args)
                        (list (append '(("objectClass" . "user")("cn" . "*")) (car args)) (car (cdr args)))))
          (let ((ldapv (netrc-machine (netrc-parse "~/.netrc") "ldapv")))
            (setq eudc-server-hotlist '(("theta" . ldap)))
            (setq ldap-host-parameters-alist
                  `(("theta"
                     base ,(netrc-get ldapv "default")
                     binddn ,(netrc-get ldapv "login")
                     passwd ,(netrc-get ldapv "password"))))
            )))
    ;; Adds some hooks

    (eval-after-load "message"
      '(define-key message-mode-map (kbd "TAB") 'eudc-expand-inline))
    (eval-after-load "sendmail"
      '(define-key mail-mode-map (kbd "TAB") 'eudc-expand-inline))
    (eval-after-load "post"
      '(define-key post-mode-map (kbd "TAB") 'eudc-expand-inline)))
#+END_SRC

** Filter atom feeds

#+BEGIN_SRC emacs-lisp
(require 'mm-url)
(defadvice mm-url-insert (after DE-convert-atom-to-rss () )
  "Converts atom to RSS by calling xsltproc."
  (when (re-search-forward "xmlns=\"http://www.w3.org/.*/Atom\""
               nil t)
    (message "Converting Atom to RSS... ")
    (goto-char (point-min))
    (call-process-region (point-min) (point-max)
             "xsltproc"
             t t nil
             (expand-file-name "~/atom2rss.xsl") "-")
    (goto-char (point-min))
    (message "Converting Atom to RSS... done")))

(ad-activate 'mm-url-insert)
#+END_SRC

** Reload gnus 

Force unload gnus (all files loaded known to me as of 2014-03-23).

#+BEGIN_SRC emacs-lisp
  (defun tom/reloadgnus ()
    "Unload all gnus files known to this function and reload gnus."
    (interactive)
    (let ((gnusfiles 
           (directory-files (expand-file-name "lisp" tom/--gnus-home) nil ".*\.el$" t)))
      (cl-loop for lib in gnusfiles do
               (ignore-errors 
                 (call-interactively
                  (unload-feature (substring-no-properties lib 0 -3)))))
      (tom/gnus)))
#+END_SRC
* mu4e

#+BEGIN_SRC emacs-lisp 
  (when (not (tom/work?))
    (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")
    (add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")
    (require 'mu4e)
    (setq mu4e-contexts
          `( ,(make-mu4e-context
               :name "goochesa"
               :match-func (lambda (_) (string-equal "goochesa" (mu4e-context-name mu4e~context-current)))
               :enter-func '()
               :leave-func (lambda () (mu4e-clear-caches))
               :vars '((mu4e-maildir . "~/Mail/Goochesa")
                       (mu4e-mu-home . "~/.mu-Goochesa")
                       (mu4e-get-mail-command . "offlineimap -a Goochesa")
                       (mu4e-drafts-folder . "/INBOX.Drafts") 
                       (mu4e-sent-folder . "/INBOX.Sent")
                       (mu4e-trash-folder . "/INBOX.Trash")
                       (user-mail-address . "tom@goochesa.de")))
             ,(make-mu4e-context
               :name "GMail"
               :match-func (lambda (_) (string-equal "GMail" (mu4e-context-name mu4e~context-current)))
               :enter-func '()
               :leave-func (lambda () (mu4e-clear-caches))
               :vars '((mu4e-maildir . "~/Mail/GMail")
                       (mu4e-mu-home . "~/.mu-GMail")
                       (mu4e-get-mail-command . "offlinegmail")
                       (mu4e-drafts-folder . "/[Google Mail].Drafts") 
                       (mu4e-sent-folder . "/[Google Mail].Sent Mail")
                       (mu4e-trash-folder . "/[Google Mail].Trash")
                       (mu4e-sent-messages-behaviour . 'delete)
                       (user-mail-address . "tomreg.tr@gmail.com")))))

    ;; something about ourselves
    (setq
     user-full-name  "Tom Regner"
     mu4e-compose-signature ""
     )

    ;; sending mail -- replace USERNAME with your gmail username
    ;; also, make sure the gnutls command line utils are installed
    ;; package 'gnutls-bin' in Debian/Ubuntu

    (require 'smtpmail)
    (setq message-send-mail-function 'smtpmail-send-it
          smtpmail-stream-type 'starttls
          smtpmail-default-smtp-server "goochesa.de"
          smtpmail-smtp-server "goochesa.de"
          smtpmail-smtp-service 587
          smtpmail-auth-credentials "~/.netrc")

    ;; don't keep message buffers around
    (setq message-kill-buffer-on-exit t))
#+END_SRC

* org-mode
** Variables
   :PROPERTIES:
   :ID:       d2eb3552-1033-4e26-ad19-f4fb5b92e551
   :END:

*** Basis / Agenda

#+BEGIN_SRC emacs-lisp
     (setq
      org-directory "~/ownCloud/org-mode"
      org-return-follows-link t
      org-src-fontify-natively t
      org-tags-exclude-from-inheritance '("PROJECT")
      org-list-allow-alphabetical nil
      org-agenda-include-inactive-timestamps t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (if (tom/work?)
      (setq org-agenda-files nil
            org-agenda-file-regexp "^\[0-9\]+")
    (setq org-agenda-files (quote ("~/ownCloud/org-mode/todos.org"
                                   "~/ownCloud/org-mode/joocom.org"))))
#+END_SRC
*** owncloud
Use ~org-cladav~ to integrate with an owncloud calendar.

x#+BEGIN_SRC emacs-lisp
  (defvar tom/--org-caldav-dir (expand-file-name "org-caldav" tom/--src-base))
  (add-to-list 'load-path tom/--org-caldav-dir)
  (require 'org-caldav)

  (defvar tom/--owncloud-base "https://muehlenweg.dyndns-home.com/owncloud/remote.php/")
  (setq
   org-caldav-url  (concat tom/--owncloud-base "caldav/calendars/tom")
   org-caldav-calendar-id "orgmode"
   org-caldav-inbox "~/ownCloud/org-mode/incoming.org"
   org-caldav-files (quote ("~/ownCloud/org-mode/todos.org"  "~/ownCloud/org-mode/joocom.org"))
   org-icalendar-timezone "Europe/Berlin")

x#+END_SRC

*** mobileorg for android

#+BEGIN_SRC emacs-lisp
  (setq
   org-mobile-directory (expand-file-name "~/ownCloud/org-mode")
   org-mobile-files (quote (org-agenda-files))
   org-mobile-inbox-for-pull (expand-file-name "~/ownCloud/org-mode/mobileorg.org"))
#+END_SRC

*** Refile

#+BEGIN_SRC emacs-lisp
(setq
    org-refile-targets (quote ((nil :maxlevel . 9)
                               (org-agenda-files :maxlevel . 9)))
    )
#+END_SRC

*** babel

The languages I like to use.

#+BEGIN_SRC emacs-lisp 
  (org-babel-do-load-languages
   'org-babel-load-languages 
   '((emacs-lisp . t)  (shell . t)
     (ditaa . t) (sass . t)
     (lisp . t) (gnuplot . t)
     (http . t)))
#+END_SRC 

The =ditaa.jar= location;

#+BEGIN_SRC emacs-lisp
  (setq org-ditaa-jar-path  (concat tom/--emacs-dir "/site/ditaa.jar"))
#+END_SRC

I really like org-babel to use zsh

#+BEGIN_SRC emacs-lisp
  (setq org-babel-sh-command "zsh")
#+END_SRC

Don't confirm evaluation.
#+BEGIN_SRC emacs-lisp
  (defun tom/ob-confirm-toggle ()
    "Turn confirmation for babel code block evaluation on/off."
    (interactive)
    (setq org-confirm-babel-evaluate (not org-confirm-babel-evaluate)))
  (global-set-key (kbd "C-c c") 'tom/ob-confirm-toggle)
#+END_SRC

Use inheritance for properties, needed for e.g. my zshorg project.
#+BEGIN_SRC emacs-lisp
  (setq org-use-property-inheritance t)
#+END_SRC

Execute code-blocks on publishing
#+BEGIN_SRC emacs-lisp
  (setq org-export-babel-evaluate t)
#+END_SRC
** Tangle hook

Remove code references in code prior to tangling; that way I can use
them anywhere in the code and get nice links/references in the weaved
document, but don't have to hide them in code comments. 

I always use the form ~(ref:label)~ for code references.

#+BEGIN_SRC emacs-lisp
  (defun tr/remove-code-labels ()
    "remove (ref:.*) from all lines"
    (goto-char (point-min))
    (let* (
           (lbl-re "[ \t]*(ref:[a-zA-Z0-9_-]*)"
                   ))
      (while (re-search-forward lbl-re nil t)
        (replace-match "")
        )))
  
  ;(add-hook 'org-babel-tangle-body-hook
  ;          (λ () (tr/remove-code-labels)))
  
#+END_SRC 

** agenda views
   :PROPERTIES:
   :ID:       ebf5af82-57f0-490c-9496-f118640b25e5
   :END:

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-custom-commands
  '(

  ("P" "Projects"
  ((tags "PROJECT")))

  ("H" "Office and Home Lists"
       ((agenda)
            (tags-todo "OFFICE")
            (tags-todo "HOME")
            (tags-todo "COMPUTER")
            (tags-todo "DVD")
            (tags-todo "READING")))
  ("O" "Office and Home Lists"
       ((agenda)
            (tags-todo "OFFICE")
            ))

  ("D" "Daily Action List"
       (
            (agenda "" ((org-agenda-ndays 1)
                        (org-agenda-sorting-strategy
                         (quote ((agenda time-up priority-down tag-up)
       )))
                        (org-deadline-warning-days 0)
                        ))))
  )
  )
#+END_SRC

** org2blog

Currently not functioning correctly.

#+BEGIN_SRC emacs-lisp
  (require 'netrc)
  (setq blog (netrc-machine (netrc-parse "~/.netrc") "joocomblog" t))
  (setq org2blog/wp-blog-alist '(("joocom"
                                  :url "http://www.joocom.de/blog/xmlrpc.php"
                                  :username (netrc-get blog "login")
                                  :password (netrc-get blog "password")
                                          ; :default-title "Toms Discovery: "
                                          ; :default-categories ("Geeks!", "Software Entwicklung", "Systemadministration")
                                          ; :tags-as-categories nil
                                  )
                                 ))

#+END_SRC 

** minted

Settings to set code in latex documents with syntax highlighting.

#+BEGIN_SRC emacs-lisp
  (setq org-latex-listings 'minted)
  (setq org-latex-packages-alist '(("" "minted")))
  (setq org-latex-custom-lang-environments
        '(
          (emacs-lisp "common-lispcode")
          (lisp "common-lispcode")
          (R "rcode")))
  (setq org-latex-minted-options
        '(("frame" "lines")
          ("fontsize" "\\scriptsize")
          ))
  (setq org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode  -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode  -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode  -output-directory %o %f"))
#+END_SRC

** =org-macs= 
Why the hell do I do this?
#+BEGIN_SRC emacs-lisp
(require 'org-macs)
#+END_SRC
** Journal
#+BEGIN_SRC emacs-lisp
  (if (not (tom/work?))
      (setq org-journal-dir (expand-file-name "~/ownCloud/org-mode/journal/"))
    (setq org-journal-dir (expand-file-name "~/Documents/journal/")))
#+END_SRC
** tomsdiner.org
#+BEGIN_SRC emacs-lisp
  ;;  (require 'org-publish)
  (if (not (tom/work?))
      (let* ((tdo (netrc-machine (netrc-parse "~/.netrc") "tdo"))
             (remote-dir (concat (netrc-get tdo "login") (netrc-get tdo "account")))
             (remote-static-dir (concat remote-dir "static/")))
        (setq org-publish-project-alist
              `(("tdo"
                 :components ("tdo-content" "tdo-static"))
                ("tdo-content"
                 :base-directory "~/Projekte/tomsdiner.org/"
                 :base-extension "org"
                 :publishing-directory ,remote-dir
                 :recursive t
                 :publishing-function org-html-publish-to-html
                 :export-with-tags nil
                 :headline-levels 4             ; Just the default for this project.
                 :with-toc nil
                 :section-numbers nil
                 :with-sub-superscript nil
                 :with-todo-keywords nil
                 :with-author nil
                 :with-creator nil
                 :with-title nil
                 :html-preamble "<div class=\"navi\">
                             <b>
                               <a href=\"/index.html\" class=\"home\">Me+Myself+I</a>
                             </b>
                             &nbsp;&mdash;&nbsp;
                             <a href=\"/myself/index.html\">myself</a>
                             &nbsp;&mdash;&nbsp;
                             <a href=\"/blog/index.html\">posts</a>
                             &nbsp;&mdash;&nbsp;
                             <a href=\"http://github.com/tomterl\">projects</a>
                           </div>
                           <hr/>"
                 :html-postamble "<hr/><div class=\"footer\">
                              <a href=\"/imprint.html\">imprint</a>
                            </div>"
                 :html-head "<link rel=\"stylesheet\"
                           href=\"/static/css/style.css\" type=\"text/css\"/><title>tomsdiner.org</title>"
                 :html-head-include-default-style nil
                 :with-timestamp t
                 :exclude-tags ("noexport" "todo")
                 :auto-preamble t)
                ("tdo-static"
                 :base-directory "~/Projekte/tomsdiner.org/static/"
                 :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf\\|otf"
                 :publishing-directory ,remote-static-dir
                 :recursive t
                 :publishing-function org-publish-attachment)))))
#+END_SRC
** Presentations
#+BEGIN_SRC emacs-lisp
(setq org-reveal-root "file:///home/tregner/opt/reveal.js")
#+END_SRC
** Books
Sections marked with `:newpage` will start on a new page when exporting to LaTeX.

#+BEGIN_SRC emacs-lisp
  (defun org/get-headline-string-element  (headline backend info)
    (let ((prop-point (next-property-change 0 headline)))
      (if prop-point (plist-get (text-properties-at prop-point headline) :parent))))

  (defun org/ensure-latex-clearpage (headline backend info)
    (when (org-export-derived-backend-p backend 'latex)
      (let ((elmnt (org/get-headline-string-element headline backend info)))
        (when (member "newpage" (org-element-property :tags elmnt))
          (concat "\\clearpage\n" headline)))))

  (eval-after-load 'ox 
    '(add-to-list 'org-export-filter-headline-functions
                  'org/ensure-latex-clearpage))
#+END_SRC
* Chat and instant messaging 

I used to use =erc=, but I'm giving circe a try -- it just turned 1.5
today :-). 

** =circe= Options

Reduce the 'leaving/enter' messages.

#+BEGIN_SRC emacs-lisp
  (enable-circe-color-nicks)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq circe-reduce-lurker-spam t)
#+END_SRC

A more fluid display setup 
#+BEGIN_SRC emacs-lisp
  (setq
   lui-time-stamp-position 'right-margin
   lui-fill-type nil)

  (define-hook-helper lui-mode ()
    (setq
     fringes-outside-margins t
     right-margin-width 7
     word-wrap t
     wrap-prefix "    "))
#+END_SRC

Put query buffers in the chat Perspective.

#+BEGIN_SRC emacs-lisp

  (define-hook-helper circe-mode ()
    (let ((-buff (current-buffer)))
      (with-perspective "chat"
        (persp-add-buffer -buff))))
#+END_SRC

Enable logging for channels, this is nice for bitlbee conversations.

The manual must be out of date, this doesn't load.

#+BEGIN_SRC emacs-lisp
;  (require 'circe)
;  (require 'lui-autoloads)
;  (enable-lui-logging)
#+END_SRC

** Color the nicknames.


** Don't show the names list at join
#+BEGIN_SRC emacs-lisp
;(circe-set-display-handler "353" (lambda (&rest args) nil))
#+END_SRC
** Spellchecking

#+BEGIN_SRC emacs-lisp
  (setq lui-flyspell-p t
        lui-flyspell-alist '((".*" "american")))
#+END_SRC

** Server 
#+BEGIN_SRC emacs-lisp
  (defun tom/set-circe-options ()
    "Set the networks options dynamically just before connection,
      after loading the passwords"
    (if (tom/work?)
        (let ((--bitlbee (netrc-machine (netrc-parse "~/.netrc") "bitlbee" t)))
          (setq circe-network-options
                (list
                 (list "Bitlbee"
                       :nick (netrc-get --bitlbee "login")
                       :nickserv-password (netrc-get --bitlbee "password")))))
      (let ((--freenode (netrc-machine (netrc-parse "~/.netrc") "freenode" t))
            (--bitlbee  (netrc-machine (netrc-parse "~/.netrc") "bitlbee" t)))
        (setq circe-network-options
              (list
               (list "ZNC"
                     :user (netrc-get --freenode "login")
                     :host "muehlenweg.dyndns-home.com"
                     :pass (netrc-get --freenode "password")
                     :port 6667
                     )
               (list "Bitlbee"
                     :nick (netrc-get --bitlbee "login")
                     :nickserv-password (netrc-get --bitlbee "password")))))))
#+END_SRC
   
** Smart connect

Straight out of the =circe= wiki

#+BEGIN_SRC emacs-lisp
  (defun circe-network-connected-p (network)
    "Return non-nil if there's any Circe server-buffer whose
  `circe-server-netwok' is NETWORK."
    (catch 'return
      (dolist (buffer (circe-server-buffers))
        (with-current-buffer buffer
          (if (string= network circe-server-network)
              (throw 'return t))))))

  (defun circe-maybe-connect (network)
    "Connect to NETWORK, but ask user for confirmation if it's
  already been connected to."
    (interactive "sNetwork: ")
    (if (or (not (circe-network-connected-p network))
            (y-or-n-p (format "Already connected to %s, reconnect?" network)))
        (circe network)))
  (defun irc ()
    "Connect to all configured IRC servers"
    (interactive)
    (persp-switch "chat")
    (tom/set-circe-options)
    (if (not (tom/work?))
        (circe-maybe-connect "ZNC"))
    (circe-maybe-connect "Bitlbee"))
#+END_SRC

** Desktop notifications

Ruben Maher expanded my idea to a full-fledged solution available on
github: [[https://github.com/eqyiel/circe-notifications]].

Notify me when tracked buffers have activity -- but not more than one
notification in a given time intervall.

#+BEGIN_SRC emacs-lisp
  (autoload 'enable-circe-notifications "circe-notifications" nil t)

  (eval-after-load "circe-notifications"
  '(setq circe-notifications-watch-strings
           '("Martin" "mregner" "Sascha" "saschab" "bgeisler" "sabrina" "olivers")
           circe-notifications-timeout 3000))

  (add-hook 'circe-server-connected-hook 'enable-circe-notifications)
#+END_SRC
** Away/Return
#+BEGIN_SRC emacs-lisp
  (defun tom/chataway ()
    "Set status to 'away NA' and reduce priority to 0"
(interactive)
    (with-current-buffer "&bitlbee"
      (goto-char (point-max))
      (insert "acc jabber set priority 0")
      (call-interactively 'lui-send-input)
      (insert "/away NA")
      (call-interactively 'lui-send-input)
      (message "You are away... (&bitlbee)")))
  (global-set-key (kbd "H-C-a") (λ (tom/chataway)))

  (defun tom/chatreturn ()
    "Set status to 'away NA' and reduce priority to 0"
(interactive)
    (with-current-buffer "&bitlbee"
      (goto-char (point-max))
      (insert "acc jabber set priority 10")
      (call-interactively 'lui-send-input)
      (insert "/away")
      (call-interactively 'lui-send-input)
      (message "Welcome back... (&bitlbee)")))
  (global-set-key (kbd "H-C-r") (λ (tom/chatreturn)))
#+END_SRC
* Behaviour
** Generic Version Control interface
#+BEGIN_SRC emacs-lisp
(fullframe vc-annotate quit-window nil)
#+END_SRC
** rgrep
#+BEGIN_SRC emacs-lisp
(fullframe/split-screen rgrep quit-window "*grep*" 'horizontal 't)
#+END_SRC
** File encoding

Everything should be in utf-8. 

#+BEGIN_SRC emacs-lisp
  (prefer-coding-system 'utf-8)
#+END_SRC

** File renaming/deletion

Both commands are from Bozhidar Batsov.

*** Renaming 
#+BEGIN_SRC emacs-lisp
(defun tom/rename-file-and-buffer ()
  "Rename the current buffer and file it is visiting."
  (interactive)
  (let ((filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "Buffer is not visiting a file!")
      (let ((new-name (read-file-name "New name: " filename)))
        (cond
         ((vc-backend filename) (vc-rename-file filename new-name))
         (t
          (rename-file filename new-name t)
          (set-visited-file-name new-name t t)))))))
#+END_SRC

*** Deletion
#+BEGIN_SRC emacs-lisp
(defun tom/delete-file-and-buffer ()
  "Kill the current buffer and deletes the file it is visiting."
  (interactive)
  (let ((filename (buffer-file-name)))
    (when filename
      (if (vc-backend filename)
          (vc-delete-file filename)
        (progn
          (delete-file filename)
          (message "Deleted file %s" filename)
          (kill-buffer))))))
#+END_SRC
** =ibuffer= as buffer screen
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC
** vi-like paren-jump
   :PROPERTIES:
   :ID:       1fada2eb-6533-42da-9c90-63042b99cbc1
   :END:
Use % to jump to corresponding parens

#+BEGIN_SRC emacs-lisp
  (defun goto-match-paren (arg)
    "Go to the matching parenthesis if on parenthesis, otherwise insert
  the character typed."
    (interactive "p")
    (cond ((looking-at "\\s\(") (forward-list 1) (backward-char 1))
      ((looking-at "\\s\)") (forward-char 1) (backward-list 1))
      (t                    (self-insert-command (or arg 1))) ))
  (global-set-key "%" `goto-match-paren)
#+END_SRC

** indentation

Indent using spaces, 2 spaces for each indentation step.

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2)
(setq-default indent-tabs-mode nil)
(setq-default c-basic-offset 2)
#+END_SRC

Indent autimatically as aggressive as possible:

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'aggressive-indent-mode)
#+END_SRC
** Flyspell: Change dictionary; key-bindings

#+BEGIN_SRC emacs-lisp
  (defun fd-switch-dictionary()
    (interactive)
    (let* ((dic ispell-current-dictionary)
           (change (if (string= dic "deutsch") "english" "deutsch")))
      (ispell-change-dictionary change)
      (message "Dictionary switched from %s to %s" dic change)
      ))
  
  (global-set-key (kbd "<f8>")   'fd-switch-dictionary)
#+END_SRC 

#+BEGIN_SRC emacs-lisp
  (require 'flyspell-correct-ido)
  (define-key flyspell-mode-map (kbd "H-;") 'flyspell-correct-previous-word-generic)
#+END_SRC
** Multiple Cursors

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
  (global-set-key (kbd "C-c M-.") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-c M-,") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c M-a") 'mc/mark-all-like-this)
#+END_SRC

*** Multicursor mark region

After using expand-region the point remains at the start of the
region. Switch point and mark and call multi-cursor.

#+BEGIN_SRC emacs-lisp
  (defun tom/mcdwim ()
    ""
    (interactive)
    (progn
      (exchange-point-and-mark)
      (mc/mark-all-dwim nil)))
  (global-set-key (kbd "\C-c r") 'tom/mcdwim)
#+END_SRC

** Expand region

Context/Language aware region expansion/contraction.

#+BEGIN_SRC emacs-lisp
  (require 'expand-region)
  (global-set-key (kbd "C-=") 'er/expand-region)
#+END_SRC

** REPL toggle

#+BEGIN_SRC emacs-lisp

  (require 'repl-toggle)
  (setq rtog/mode-repl-alist '(
                               (php-mode . tom/psysh) 
                               (emacs-lisp-mode . ielm)
                               (elixir-mode . elixir-mode-iex)
                               (ruby-mode . inf-ruby)
                               (js2-mode . nodejs-repl)
(js3-mode . nodejs-repl)))
  (setq rtog/fullscreen t)
  (setq rtog/split-screen t)
#+END_SRC

** Opening URLs

Send them to firefox, with keysnail much better then anything else.

#+BEGIN_SRC emacs-lisp
  (setq
   browse-url-browser-function (quote browse-url-firefox))
#+END_SRC

** Sidebar
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (concat tom/--emacs-dir "/sidebar.el"))
  (require 'sidebar)
  (global-set-key (kbd "H-s") 'sidebar-open)
#+END_SRC
** Scrolling

Scroll as much as other programs do, one line at a time and with
enough context around point visible.

#+BEGIN_SRC emacs-lisp
(require 'smooth-scrolling)
(smooth-scrolling-mode)
#+END_SRC

** Insert current date

Use the 'calendar' to get and format the date.

#+BEGIN_SRC emacs-lisp
  (require 'calendar)

  (defun tom/insert-current-date (&optional omit-day-of-week-p)
    "Insert today's date using the current locale.
      With a prefix argument, the date is inserted without the day of
      the week."
    (interactive "P*")
    (insert (calendar-date-string (calendar-current-date) nil
                                  omit-day-of-week-p)))
  (global-set-key (kbd "\C-c d") 'tom/insert-current-date)
#+END_SRC
** Window movement

See hydra above for movement!

*** Window Layouts / Rotation

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "H-r") 'rotate-window)
  (global-set-key (kbd "H-C-l") 'rotate-layout)
#+END_SRC

** EDiff

Sensible setup found at 'or emacs('.

#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-diff-options "-w")
  (defun tom/ediff-hook ()
    (ediff-setup-keymap)
    (define-key ediff-mode-map "j" 'ediff-next-difference)
    (define-key ediff-mode-map "k" 'ediff-previous-difference))

  (add-hook 'ediff-mode-hook 'tom/ediff-hook)

#+END_SRC
** dired
#+BEGIN_SRC emacs-lisp
  (require 'dired-x)
  (put 'dired-find-alternate-file 'disabled nil)
  (setq dired-omit-files "^\\..*$")
#+END_SRC
** highlights
#+BEGIN_SRC emacs-lisp
  (require 'volatile-highlights)
  (vhl/define-extension 'ut 'undo-tree-redo 'undo-tree-undo)
  (vhl/load-extension 'ut)
  (define-hook-helper prog-mode ()
    (volatile-highlights-mode 1))
#+END_SRC
** Edit as root
#+BEGIN_SRC emacs-lisp
  (defun tom/sudo ()
    "Use TRAMP to `sudo' the current buffer"
    (interactive)
    (when buffer-file-name
      (find-alternate-file
       (concat "/sudo:root@localhost:"
               buffer-file-name))))
#+END_SRC
** Case handling
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "H-c") 'string-inflection-all-cycle)
#+END_SRC
** Lookup documentation 
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "H-z") 'zeal-at-point)
#+END_SRC
** Occur ~word-at-point~
#+BEGIN_SRC emacs-lisp
  (defun tom/occur-tap ()
    "Call occur with word-at-point"
    (interactive)
    (occur (word-at-point))
    )
  (defun tom/kill-occur-window ()
    "Kill the *Occur* buffer/window"
    (interactive)
    (let ((buffer (get-buffer "*Occur*")))
      (when buffer
        (with-current-buffer-window
         buffer
         nil
         nil
         (kill-buffer-and-window)))))
  (global-set-key (kbd "H-f") 'tom/occur-tap)
  (global-set-key (kbd "H-F") 'tom/kill-occur-window)
#+END_SRC
** View buffers
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "H-v") 'view-mode)
#+END_SRC
** Multiple Major Modes
#+BEGIN_SRC emacs-lisp
  (require 'mmm-mode)
  (mmm-add-classes
   '((embedded-aql
      :submode aql-mode
      :front "^\\(.*aql`\\)"
      :front-offset (end-of-line 1)
      :back "`"
      :insert ((?a embaql nil
                   @ "var query = aql`" @ "\n" _ "\n" @ "`;" @)))
     (embedded-sql
      :submode sql-mode
      :front "^\\(.*$\\(source\\|sql\\) = [\"']\\)"
      :back "[\"'];"
      :insert ((?s embsql "Varname (source|sql)? "
                   @ "$" str " = \"\n" @ _ @ "\n\";" @)
               (?o embsqlsource ?s . "source")
               (?q embsqlsql ?s . "sql"))
      :front-offset (end-of-line 1)
      :save-matches t)
     (embedded-js
      :submode js2-mode
      :front "^        body: >"
      :front-offset '(end-of-line 11)
      :back  "\\(^      - name: \\)\\|\\(^    types:\\)")))
  (setq mmm-global-mode 'maybe)
  (mmm-add-mode-ext-class 'js2-mode nil 'embedded-aql)
  (mmm-add-mode-ext-class 'php-mode nil 'embedded-sql)
  (mmm-add-mode-ext-class 'yaml-mode nil 'embedded-js)
#+END_SRC
*** Edit in different mode in narrowed buffer
#+BEGIN_SRC emacs-lisp
  (defmacro tom/edit-narrowed (mode mark begin end &optional fun)
    "If point is inside a `begin...end' block, create a narrowed,
    indirect buffer in `mode' to edit the contents between those
    markers. 

    Press `C-c C-c' inside the buffer to close the window
    and kill the indirect buffer.

    `mark' is used in the construction of the name for the indirect buffer.

    If `fun' is given, it is called with the narrowed buffer as current buffer."
    `(let ((bufname (concat " *"(buffer-name) "." ,mark  "*")))
       (with-current-buffer (if (get-buffer bufname) bufname (clone-indirect-buffer bufname nil))
         (unless (buffer-narrowed-p)
           (let ((max (- (search-forward-regexp ,end) (- (match-end 0) (match-beginning 0))))
                 (min (+ (search-backward-regexp ,begin) (- (match-end 0) (match-beginning 0)))))
             (narrow-to-region min max)))
         (funcall ,mode)
         (aggressive-indent-mode nil)
         (font-lock-fontify-block)
         (if (functionp ,fun) (funcall ,fun))
         (local-set-key (kbd "C-c C-c") #'(lambda ()
                                            (interactive)
                                            (progn
                                              (kill-this-buffer)
                                              (delete-window (selected-window))
                                              (mmm-parse-buffer))))
         (pop-to-buffer bufname))))

#+END_SRC
** Help
#+BEGIN_SRC emacs-lisp
  (global-set-key
   (kbd "H-h")
   (defhydra hydra-help (:color blue :timeout 3)
     "launch"
     ("h" helpful-at-point "Loopup Function/Macro")
     ("v" helpful-variable "Lookup Variable")
     ("g" helpful-update "Refresh Helpful Buffer")
     ))
#+END_SRC
** todo-extraction
#+BEGIN_SRC emacs-lisp
  (require 'doom-todo-ido)
#+END_SRC
* Languages
** Elixir

Automatically add =end= when typing =do=.

#+BEGIN_SRC emacs-lisp
  (require 'elixir-mode)
  (add-to-list
   'elixir-mode-hook
   (defun auto-activate-ruby-end-mode-for-elixir-mode ()
     (set (make-variable-buffer-local 'ruby-end-expand-keywords-before-re)
          "\\(?:^\\|\\s-+\\)\\(?:do\\)")
     (set (make-variable-buffer-local 'ruby-end-check-statement-modifiers) nil)
     (ruby-end-mode +1)))
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (define-hook-helper elixir-mode ()
    (progn 
      (require 'alchemist)
      (set (make-local-variable 'company-backends)
           '((Alchemist-company :with company-yasnippet company-dabbrev-code)))
      (flycheck-mode 1)
      (yas-minor-mode 1)))
#+END_SRC
*** Imenu 

Add speedbar support for elixir files.

#+BEGIN_SRC emacs-lisp
  (require 'speedbar)
  (speedbar-add-supported-extension ".ex")
  (speedbar-add-supported-extension ".exs")
#+END_SRC

** Rust

#+BEGIN_SRC emacs-lisp
  (setenv "RUST_SRC_PATH" "/home/tom/Projects/rust/src")
  (define-hook-helper rust-mode ()
    (progn
      (require 'company-racer)
      (setq tab-width 4
            c-basic-offset 4
            indent-tabs-mode nil
            )
      (set (make-local-variable 'company-backends)
           '((company-racer :with :sorted company-yasnippet)))
      (cargo-minor-mode 1)))
#+END_SRC
** Shell
#+BEGIN_SRC emacs-lisp
  (define-hook-helper sh-mode ()
    (flycheck-mode 1))
#+END_SRC
** PHP
*** Use php-mode, not web-mode for PHP-code

#+BEGIN_SRC emacs-lisp
(require 'php-mode)
  (add-to-list 'auto-mode-alist '("\\.php$" . php-mode))
  (add-to-list 'auto-mode-alist '("\\.inc$" . php-mode))
#+END_SRC

*** smarty 

Use ~web-mode~ for smarty templates.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.tpl$" . web-mode))
#+END_SRC
*** Indentation and behaviour

Indent with 4 spaces. Use flycheck, but dont't use the "controversial" and "cleancode" rulesets of phpmd. Use ~ac-php~ as company backend. Recreate the tags when a file is saved.

#+BEGIN_SRC emacs-lisp
  (defun tom/php-tags-update ()
    ""
    (if (and (boundp 'call-php-tags-func) call-php-tags-func)
        (ac-php-remake-tags)))
  ;;  (add-hook 'after-save-hook 'tom/php-tags-update)

  (defun tom/dtw ()
    ""
    (save-excursion
      (delete-trailing-whitespace)))

  (define-hook-helper php-mode ()
    (progn 
      (require 'company-php)

      (ggtags-mode -1)
      (repl-toggle-mode 1)
      (yas-minor-mode 1)
      (company-mode 1)
      (set (make-local-variable 'call-php-tags-func) t)
      (local-set-key (kbd "C-c a") 'tom/edit-sql)
      (php-enable-wordpress-coding-style)

      (setq tab-width 4
            c-basic-offset 4
            indent-tabs-mode nil
            php-template-compatibility nil
            flycheck-phpmd-rulesets '("unusedcode")

            php-mode-coding-style (quote wordpress)
            php-lineup-cascaded-calls t)
      (add-hook 'write-contents-functions 'tom/dtw nil t)
      (flycheck-may-enable-checker 'php-phpcs)
      (flycheck-disable-checker 'php-phpmd)
      (define-key lsp-ui-mode-map [remap xref-find-definitions] #'lsp-ui-peek-find-definitions)
      (define-key lsp-ui-mode-map [remap xref-find-references] #'lsp-ui-peek-find-references)
      (setq-local flycheck-checker nil)
      (setq-local flycheck-checker 'lsp-php-ui)
      (message "tom/php-mode-hook executed")))

  (require 'lsp-mode)
  (require 'lsp-imenu)
  (add-hook 'lsp-after-open-hook 'lsp-enable-imenu)
  (require 'lsp-ui)
  (add-hook 'lsp-mode-hook 'lsp-ui-mode)

  (require 'lsp-php)
  (add-hook 'php-mode-hook #'lsp-php-enable)
  (add-hook 'php-mode-hook 'flycheck-mode)

  (flycheck-define-generic-checker 'lsp-php-ui
    "A syntax checker using the Language Server Protocol (RLS)
    provided by lsp-mode.
    See https://github.com/emacs-lsp/lsp-mode."
    :start #'lsp-ui-flycheck--start
    :modes '(php-mode) ; Need a default mode
    :predicate (lambda () lsp-mode)
    :error-explainer (lambda (e) (flycheck-error-message e))
    :next-checkers '((warning . php)))
#+END_SRC
*** Remote debugging

Geben has a new maintainer, it has some issues, but is overall working sufficiently well.

 #+BEGIN_SRC emacs-lisp
   (setq geben-dbgp-default-port 9000)
   (setq geben-display-window-function 'switch-to-buffer)
   (setq geben-full-frame-mode t)
 #+END_SRC

Reroute remote paths to my dev-server and the vagrant user via tramp.

#+BEGIN_SRC emacs-lisp
  (defun tom/geben-tramp-spec (remote-path)
    ""
    (print "/sshx:vagrant@192.168.254.254:"))
  (fset 'geben-get-tramp-spec-for 'tom/geben-tramp-spec)
#+END_SRC

Make the context window sticky
#+BEGIN_SRC emacs-lisp
  (setq tom/geben-context-buffer-name "*GEBEN<127.0.0.1:9000> context*")
  (defadvice geben-display-context (after sticky-geben-context-window activate)
    (tom/sticky-window tom/geben-context-buffer-name))
  (defadvice geben-display-context (before sticky-geben-context-window activate)
    (unless (buffer-live-p (get-buffer tom/geben-context-buffer-name))
      (split-window-right)))
#+END_SRC
*** Check/correct @param tags
Check the doc comment of the current function for @param tags, create them if not present. This is used in the function-snippet, but needs an overhaul...

#+BEGIN_SRC emacs-lisp
  (defun tom/php-check-params ()
    ""
    (interactive)
    (save-excursion
      (narrow-to-defun t)
      (goto-char (point-min))
      (search-forward-regexp "function[^(]*(\\(.*\\))\\(?:;\\| {\\)")
      (let ((params (split-string (match-string-no-properties 1) ", " t " ")))
        (dolist (param params)
          (let* ((parts (split-string param " "))
                 (pname (if (cadr parts) (cadr parts) (car parts)))
                 (param-parts (split-string pname "=" t " "))
                 (type (if (cadr parts) (car parts) nil))
                 (name (car param-parts))
                 (default (cadr param-parts))
                 (typemsg (if type type (if (numberp default) "int" "mixed")))
                 (defaultmsg (if default
                                 (concat "optional, default '"
                                         (if (numberp default)
                                             (number-to-string default)
                                           default)
                                         "'")
                               "")))
            (save-excursion
              (unless (search-backward-regexp (concat "@param .*" name) nil t)
                (let* ((text1 (s-trim (s-join " " (list typemsg name defaultmsg))))
                       (param-text (s-join " " (list "\n* @param" text1))))
                  (if (> (length text1) 0)
                      (progn
                        (goto-char (point-max))
                        (if (search-backward-regexp "^ +\\* *$" nil t)
                            (goto-char (line-end-position))
                          (progn
                            (goto-char (point-min))
                            (insert "/**\n*/\n")(backward-char 4)))
                        (insert param-text)
                        (indent-according-to-mode)
                        (insert "\n* ")
                        (indent-according-to-mode)))))))))
      (widen)))
#+END_SRC
*** ~phpunit~
#+BEGIN_SRC emacs-lisp
  (defun tom/php-unit ()
    ""
    (interactive)
    (let* ((pr (projectile-project-root))
           (confdir (concat pr "/tests"))
           (conf (concat confdir "/phpunit.xml"))
           (wd default-directory))
      (if (and (file-directory-p confdir) (file-exists-p conf))
          (progn
            (cd confdir)
            (phpunit-run '())
            (cd wd)))))
#+END_SRC

*** ~psysh~
#+BEGIN_SRC emacs-lisp
  (defun tom/psysh ()
    "Start or switch to a psysh specific to the current
            projectile project, or the global '*PsySh*' if not in a
            project"
    (interactive)
    (if (projectile-project-p)
        (let* ((-project-root (projectile-project-root))
               (-project (projectile-default-project-name -project-root))
               (-buffer-name (concat "* " -project " psysh *")))
          (ansi-term (concat -project-root "bin/shell.php") -buffer-name))
      (psysh-run "*PsySh*" "psysh")))

  (define-hook-helper psysh-mode () 
    (progn (company-mode -1) (auto-complete-mode)))
#+END_SRC
** C
*** Indentation
#+BEGIN_SRC emacs-lisp
  (define-hook-helper c-mode ()
    (setq tab-width 2
          c-basic-offset 2
          indent-tabs-mode nil))
#+END_SRC
** JavaScript
*** Indentation etc
#+BEGIN_SRC emacs-lisp
  (if (tom/work?)
      (setq js-indent-level 4
            js2-basic-offset 4
            js2-bounce-indent-p t)
    (setq js-indent-level 2
          js2-basic-offset 2
          js2-bounce-indent-p t))
  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
#+END_SRC
*** Completion
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "/usr/lib/node_modules/tern/emacs")
  (defun tom/company-transformer (candidates)
    (let ((completion-ignore-case t))
      (all-completions (company-grab-symbol) candidates)))

  (define-hook-helper js2-mode ()
    (progn
      (ggtags-mode -1)
      (flycheck-mode 1)
      (repl-toggle-mode 1)
      (yas-minor-mode 1)
      (company-mode 1)
      (make-local-variable 'company-transformers)
      (push 'tom/company-transformer company-transformers)
      (define-key lsp-ui-mode-map [remap xref-find-definitions] #'lsp-ui-peek-find-definitions)
      (define-key lsp-ui-mode-map [remap xref-find-references] #'lsp-ui-peek-find-references)
      (define-key lsp-ui-mode-map (kbd "M-.") #'lsp-ui-peek-find-definitions)
      (local-set-key
       (kbd "H-j")
       (defhydra hydra-js2-refactor (:color blue :timeout 5)
         "Refactor javascript"
         ("ta" #'js2r-toggle-arrow-function-and-expression "toggle arrow")
         ("rv" #'js2r-rename-var "rename variable")))
      (local-set-key (kbd "C-c a") 'tom/edit-aql)))

  (require 'lsp-javascript-typescript)
  (add-hook 'js2-mode-hook #'lsp-javascript-typescript-enable)
  (flycheck-define-generic-checker 'lsp-js-ui
    "A syntax checker using the Language Server Protocol (RLS)
    provided by lsp-mode.
    See https://github.com/emacs-lsp/lsp-mode."
    :start #'lsp-ui-flycheck--start
    :modes '(js2-mode) ; Need a default mode
    :predicate (lambda () lsp-mode)
    :error-explainer (lambda (e) (flycheck-error-message e))
    :next-checkers '((warning . javascript)))
#+END_SRC
*** Refectoring 
#+BEGIN_SRC emacs-lisp
  (require 'js2-refactor)
  (js2r-add-keybindings-with-prefix "C-c C-m")
  (add-hook 'js2-mode-hook #'js2-refactor-mode)


#+END_SRC
*** Edit js in YAML-files
#+BEGIN_SRC emacs-lisp
  (defun tom/edit-js ()
    "If point is between a `^ body: > ... \\(^ - name: \\)\\|\\(^ types:\\)'
  block, create a narrowed, indirect buffer in `js2-mode' to edit the
  function-body.  Press `C-c C-c' inside the buffer to close the window
  and kill the indirect buffer."
    (interactive)
    (tom/edit-narrowed 'js2-mode ".js" "^        body: >" "\\(^      - name: \\)\\|\\(^    types:\\)"))
#+END_SRC
*** nodejs-repl 
#+BEGIN_SRC emacs-lisp
  (require 'nodejs-repl)
  (add-to-list 'nodejs-repl-arguments "--harmony_regexp_property")
#+END_SRC
*** `.aql` files 
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.aql" . js-mode))
#+END_SRC
** YAML

Associate ~yaml-mode~ with formular (~.frm~) and table (~.tbl~)
definitions as used in fb-core et.al.

#+BEGIN_SRC emacs-lisp
  (require 'yaml-mode)
  (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
  (add-to-list 'auto-mode-alist '("\\.frm$" . yaml-mode))
  (add-to-list 'auto-mode-alist '("\\.tbl$" . yaml-mode))
  (define-hook-helper yaml-mode ()
    (progn
      (setq tab-width 2
            c-basic-offset 2
            indent-tabs-mode nil)
      (yas-minor-mode 1)
      (aggressive-indent-mode -1)
      (local-set-key (kbd "C-c a") 'tom/edit-js)))
#+END_SRC

** Groovy

#+BEGIN_SRC emacs-lisp
;;;  (require 'inf-groovy)
  (add-to-list 'auto-mode-alist '("\\.gvy$" . groovy-mode))
  (rtog/add-repl 'groovy-mode (rtog/switch-to-shell-buffer "*groovy*" 'run-groovy))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (define-hook-helper haskell-mode ()
    (progn
      (hindent-mode 1)
      (aggressive-indent-mode -1)))

  (let ((my-cabal-path (expand-file-name "~/.cabal/bin")))
    (setenv "PATH" (concat my-cabal-path path-separator (getenv "PATH")))
    (add-to-list 'exec-path my-cabal-path))
  (custom-set-variables '(haskell-tags-on-save t))
  (custom-set-variables
   '(haskell-process-suggest-remove-import-lines t)
   '(haskell-process-auto-import-loaded-modules t)
   '(haskell-process-log t)
   '(haskell-process-type 'cabal-repl)
   '(hindent-style "gibiansky"))

  (eval-after-load 'haskell-mode
    '(progn
       (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-or-reload)
       (define-key haskell-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
       (define-key haskell-mode-map (kbd "C-c C-n C-t") 'haskell-process-do-type)
       (define-key haskell-mode-map (kbd "C-c C-n C-i") 'haskell-process-do-info)
       (define-key haskell-mode-map (kbd "C-c C-n C-c") 'haskell-process-cabal-build)
       (define-key haskell-mode-map (kbd "C-c C-n c") 'haskell-process-cabal)))
  (eval-after-load 'haskell-cabal
    '(progn
       (define-key haskell-cabal-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
       (define-key haskell-cabal-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
       (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
       (define-key haskell-cabal-mode-map (kbd "C-c c") 'haskell-process-cabal)))
#+END_SRC

** AQL
#+BEGIN_SRC emacs-lisp
  (require 'aql-mode)
  (define-hook-helper aql-mode ()
    (progn
      (setq tab-width 2
            c-basic-offset 2
            indent-tabs-mode nil)
      (yas-minor-mode 1)
      (aggressive-indent-mode -1)
      (local-set-key (kbd "C-c a") 'tom/edit-aql)))
#+END_SRC
*** Edit AQL in ~js2-mode~
#+BEGIN_SRC emacs-lisp
  (defun tom/edit-aql ()
    "If point is inside a `aql\`...\`' block, create a narrowed,
  indirect buffer in `aql-mode' to edit the statement.  Press `C-c
  C-c' inside the buffer to close the window and kill the indirect
  buffer."
    (interactive)
    (tom/edit-narrowed 'aql-mode ".aql" "aql`" "`"))
#+END_SRC
** SQL
#+BEGIN_SRC emacs-lisp
  (require 'sql)
  (define-hook-helper sql-mode ()
    (progn
      (setq tab-width 2
            c-basic-offset 2
            indent-tabs-mode nil)
      (yas-minor-mode 1)
      (aggressive-indent-mode nil)
      (local-set-key (kbd "C-c a") 'tom/edit-sql)
      (local-set-key (kbd "C-c C-c") 'sql-send-paragraph)))
#+END_SRC
*** Edit SQL in ~php-mode~
#+BEGIN_SRC emacs-lisp
  (defun tom/edit-sql ()
    "If point is inside a `$source = \'...\';' block, create a narrowed,
        indirect buffer in `sql-mode' to edit the statement.  Press `C-c
        C-c' inside the buffer to close the window and kill the indirect
        buffer."
    (interactive)
    (tom/edit-narrowed 'sql-mode
                       ".sql"
                       "$\\(source\\|sql\\) = [\"']"
                       "[\"'];"
                       #'(lambda ()
                           (progn
                             (load-library "sql-indent")
                             (set (make-local-variable 'indent-line-function) 'sql-indent-line)
                             (setq sql-product "postgres")))))
#+END_SRC

* RESTful
** Extract json-field data
#+BEGIN_SRC emacs-lisp
  (defun tom/extract-json (name)
    "Extract the field `NAME' from the restclient-result buffer (`*HTTP Response*'). 
  Caution: This parses the hole buffer as json-data, so may be costly.

  `NAME' may be given as dotted path to address nested json-objects
  "
    (with-current-buffer "*HTTP Response*"
      (let* ((json-object-type 'hash-table)
             (json-array-type 'list)
             (json-key-type 'string)
             (names (split-string name "\\." t))
             (result nil)
             (data (json-read-from-string (buffer-string))))
        (reduce #'(lambda (value key) "" (gethash key value)) names :initial-value data))))
#+END_SRC

** Use ~outline-cycle~ in rest-buffers
#+BEGIN_SRC emacs-lisp
  (eval-after-load 'outline
    '(progn
       (require 'outline-magic)
       (define-key outline-minor-mode-map
         (kbd "<C-tab>")
         'outline-cycle)))
#+END_SRC
* Databases
** ElasticSearch

#+BEGIN_SRC emacs-lisp
  (autoload 'es-mode "es-mode.el" "Major mode for editing Elasticsearch queries." t)
  (add-to-list 'auto-mode-alist '("\\.es$" . es-mode))
  (add-hook 'es-result-mode-hook 'hs-minor-mode)
#+END_SRC

* Slime

#+BEGIN_SRC emacs-lisp
  ;;;(load (expand-file-name "~/quicklisp/slime-helper.el"))
  ;; Replace "sbcl" with the path to your implementation
  (setq inferior-lisp-program "sbcl")
#+END_SRC

* Version control
** Magit 
 
*** Magithub integration.

#+BEGIN_SRC emacs-lisp
  (setq magithub-feature-autoinject t)
  (require 'magithub)

#+END_SRC
*** Configuration
#+BEGIN_SRC emacs-lisp
  (require 'magit)
  (setq magit-last-seen-setup-instructions "1.4.0")
  (setq magit-completing-read-function 'magit-ido-completing-read)
#+END_SRC
   
*** Key bindings
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f7>") 'magit-status)
#+END_SRC

*** Fullscreen

#+BEGIN_SRC emacs-lisp
(fullframe magit-status magit-mode-quit-window nil)
#+END_SRC

* Services
** =ssh= tunnel

Manage ssh tunnel via prodigy.

#+BEGIN_SRC emacs-lisp
(require 'prodigy)
#+END_SRC
*** Helper functions

**** Build the argument list

#+BEGIN_SRC emacs-lisp
  (defun tom/build-tunnel-args (args)
    "Assemble the ssh tunnel argument list."
    `("-v" ;; allows us to parse for the ready message
      "-N" ;; don't start an interactive shell remotely
      "-L" ,(concat (getf args :localport) ;; the tunnel spec
                    ":"
                    (getf args :tunnel-ip)
                    ":"
                    (getf args :tunnel-port))
      "-l" ,(getf args :user) ;; the username
      "-p" ,(getf args :port) ;; the remote port
      ,(getf args :host)))    ;; the remote host
#+END_SRC

*** Tunnel tag

#+BEGIN_SRC emacs-lisp
  (prodigy-define-tag
    :name 'ssh-tunnel
    :command "ssh"
    :cwd (getenv "HOME")
    :args (prodigy-callback (service)
            (tom/build-tunnel-args
             (getf service :tunnel)))
    :ready-message "debug1: Entering interactive session.")
#+END_SRC

*** Tunnel services

Tunnel definitions are held outside this config to protect the innocent...

#+BEGIN_SRC emacs-lisp
(load-file "~/ownCloud/dotfiles/prodigy.el")

#+END_SRC
** Work Services
#+BEGIN_SRC emacs-lisp
  (when (tom/work?)
    (load-file "~/ownCloud/dotfiles/workservices.el"))
#+END_SRC
* Paste services
** ix.io

#+BEGIN_SRC emacs-lisp
  (let ((ix-io (netrc-machine (netrc-parse "~/.netrc") "ix-io")))
    (setq ix-user (netrc-get ix-io "login"))
    (setq ix-token (netrc-get ix-io "password")))
#+END_SRC

** yagist

#+BEGIN_SRC emacs-lisp
  (let ((github (netrc-machine (netrc-parse "~/.netrc") "yagist")))
    (setq yagist-github-token (netrc-get github "password")))
#+END_SRC

* Search 
** the silver searcher

 I use ag.el to interact with ag, a fine replacement for grep.
 Ignore all ignore-files :-)

#+BEGIN_SRC emacs-lisp
(setq ag-arguments (list "-U" "--numbers" "--smart-case" "--nogroup" "--column" "--stats" "--"))
#+END_SRC

Focus on the current window and the ag-result buffer.

#+BEGIN_SRC emacs-lisp
(fullframe/split-screen ag quit-window "*ag search*" 'horizontal 't)
#+END_SRC

Setup `wgrep-ag`.

#+BEGIN_SRC emacs-lisp 
  (autoload 'wgrep-ag-setup "wgrep-ag")
  (add-hook 'ag-mode-hook 'wgrep-ag-setup)
#+END_SRC

Delete the ~File:~ prefix appended by ~ag~ to the output, let `compile-find-file` work again.

#+BEGIN_SRC emacs-lisp
  (define-advice compilation-find-file (:around (orig-fun &rest args) remove-file-prefix -100)
    (let* ((to-find (car (cdr args)))
           (newname (s-replace "File: " "" to-find)))
      (setcar (cdr args) newname)
      (apply orig-fun args)))

#+END_SRC
* Passwords
*** Basic setup
 #+BEGIN_SRC emacs-lisp
   (require 'org-passwords)
   (setq org-passwords-file "~/.auth.gpg")
   (setq org-passwords-random-words-dictionary "/etc/dictionaries-common/words")
 #+END_SRC
*** capture template
 #+BEGIN_SRC emacs-lisp
   (require 'org-capture)
   (add-to-list 'org-capture-templates
                '("p" "password" entry (file "~/.auth.gpg")
                  "* %^{Title}\n  %^{URL}p %^{USERNAME}p %^{PASSWORD}p"))
 #+END_SRC
*** keybindings
 #+BEGIN_SRC emacs-lisp
   (eval-after-load "org-passwords"
     '(progn
        (define-key org-passwords-mode-map
          (kbd "C-c C-c")
          'org-passwords-copy-username)
        (define-key org-passwords-mode-map
          (kbd "C-c C-p")
          'org-passwords-copy-password)
        (define-key org-passwords-mode-map
          (kbd "C-c C-o")
          'org-passwords-open-url)))

 #+END_SRC

* Diminish Modes

Do this after everything is setup.

#+BEGIN_SRC emacs-lisp
  (diminish 'golden-ratio-mode "")
  (diminish 'undo-tree-mode "")
  (diminish 'whitespace-mode "")
  (diminish 'company-mode "")
  (diminish 'org-src-mode "")
  (diminish 'projectile-mode "")
  (diminish 'yas-minor-mode "")
  (diminish 'flycheck-mode "")
  (diminish 'repl-toggle-mode "")
  (diminish 'mmm-mode "") 
  (diminish 'persp-mode "")
  (diminish 'company-box-mode "")
  (diminish 'volatile-highlights-mode "")
  (diminish 'eldoc-mode "")
  (diminish 'visual-line-mode "")
  (diminish 'abbrev-mode "")
  (diminish 'auto-revert-mode "")
#+END_SRC

* Server
** httpd server
#+BEGIN_SRC emacs-lisp
  (setq httpd-port 8081)
  (setq httpd-host "0.0.0.0")
#+END_SRC
** emacs server
Always have an emacs server running.

#+BEGIN_SRC emacs-lisp
(require 'server)
(unless (server-running-p)
  (org-reload) ; switch to newest org from melpa
  (server-start))
#+END_SRC

